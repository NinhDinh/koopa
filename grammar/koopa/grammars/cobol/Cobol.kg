## #############################################################################
## Top level definitions.
## -----------------------------------------------------------------------------

# Compilation group.
def compilationGroup =
	( compilationUnit )*
end

# Copybook. This is just a guess at the likely suspect(s).
def copybook =
    ( copybookHoldingData
    | copybookHoldingBehaviour
    )
end

def copybookHoldingData =
    ( dataDescriptionEntry
    | copyStatement
    | replaceStatement
    | execStatement [.]
    )+
end

def copybookHoldingBehaviour =
    (sentence)*
    (paragraph)*
    (section)*
end

## #############################################################################
## Compilation unit.
## -----------------------------------------------------------------------------

# Compilation unit.
def compilationUnit =
	identificationDivision
 	[environmentDivision]
 	[dataDivision]
	[procedureDivision
	  (compilationUnit)*
	]
	[END PROGRAM programName .]
end

## #############################################################################
## IDENTIFICATION DIVISION .
## -----------------------------------------------------------------------------

def identificationDivision =
	( ID | IDENTIFICATION ) DIVISION .
	PROGRAM-ID [.]
	programName
	[ [IS]
	  ( INITIAL [COMMON]
	  | COMMON [INITIAL] 
	  )
	  [PROGRAM]
	]
	[.]
	[--> divisionStart]
end

## #############################################################################
## ENVIRONMENT DIVISION .
## -----------------------------------------------------------------------------

def environmentDivision =
	ENVIRONMENT DIVISION .
	[configurationSection]
	[ioSection]
	[--> divisionStart]
end

## Configuration Section
def configurationSection =
	CONFIGURATION SECTION .
	!(sourceComputerParagraph
	| objectComputerParagraph
	| specialNamesParagraph)
	[--> (environmentSectionStart | divisionStart)]
end

def sourceComputerParagraph =
	SOURCE-COMPUTER .
	[computerName [withDebuggingMode] .]
	[--> (confParagraphStart | environmentSectionStart | divisionStart)]
end

def withDebuggingMode =
	[WITH] DEBUGGING MODE
end

def objectComputerParagraph =
	OBJECT-COMPUTER .
	[computerName [--> .] .]
	[--> (confParagraphStart | environmentSectionStart | divisionStart)]
end

def genericStringDef =
	(alphanumeric)*
	[WITH DEBUGGING]
	[.]
end

def specialNamesParagraph =
	SPECIAL-NAMES .
	[decimalIsComma]
	[--> (confParagraphStart | environmentSectionStart | divisionStart)]
end

def decimalIsComma = 
	DECIMAL-POINT [IS] COMMA [.]
end

def confParagraphStart =
	(SOURCE-COMPUTER | OBJECT-COMPUTER 
	| SPECIAL-NAMES) .
end

## input-Output Section
def ioSection =
	INPUT-OUTPUT SECTION .
	fileControlParagraph
	[ioControlParagraph]
	[--> divisionStart]
end

# TODO only skeletal implementation of this paragraph until now...
def fileControlParagraph =
	FILE-CONTROL .
	(selectStatement)*
end

def selectStatement = 
	selectClause
	assignClause
	!(organizationIsSequentialClause 
	| fileStatusClause)
	[--> .]
	.
end

def selectClause =
	SELECT
	[OPTIONAL]
	fileName
end

def assignClause =
	ASSIGN
	(assignUsingClause
	| assignToClause)
end

def assignUsingClause =
	USING
	dataName
end

def assignToClause =
	[TO]
	assignmentName
end

def organizationIsSequentialClause =
	[ORGANIZATION [IS]]
	SEQUENTIAL
end

def fileStatusClause =
	[FILE] STATUS [IS]
	dataName
	[dataName]
end

def ioControlParagraph =
	I-O-CONTROL .
	[--> divisionStart]
end

# Start of section in environment division.
def environmentSectionStart =
    ( CONFIGURATION
    | INPUT-OUTPUT
    ) SECTION .
end

## #############################################################################
## DATA DIVISION .
## -----------------------------------------------------------------------------

def dataDivision =
	DATA DIVISION .
	[fileSection]
	[workingStorageSection]
	[localStorageSection]
	[linkageSection]
	[communicationSection]
	[reportSection]
#	[--> divisionStart]
end

def fileSection =
	FILE SECTION .
	( fileDescriptionEntry (recordDescriptionEntry)* )*
    [--> (dataSectionStart | divisionStart)]
end

def recordDescriptionEntry =
	(dataDescriptionEntry | copyStatement)
end

def localStorageSection =
	LOCAL-STORAGE SECTION .
	( recordDescriptionEntry
    | replaceStatement
    | execStatement [.]
    )*
end

def workingStorageSection =
	WORKING-STORAGE SECTION .
    ( recordDescriptionEntry
    | replaceStatement
    | execStatement [.]
    )*
#    [--> (dataSectionStart | divisionStart)]
end

def linkageSection =
	LINKAGE SECTION .
    ( recordDescriptionEntry
    | replaceStatement
    | execStatement [.]
    )*
#    [--> (dataSectionStart | divisionStart)]
end

def communicationSection =
	COMMUNICATION SECTION .
    [--> (dataSectionStart | divisionStart)]
end

def reportSection =
	REPORT SECTION .
    [--> (dataSectionStart | divisionStart)]
end

def fileDescriptionEntry =
    ( fdFileDescriptionEntry
    | sdFileDescriptionEntry
    )
end

def fdFileDescriptionEntry =
    FD fileName
   !( blockContains
    | codeSet
    | dataRecords
    | external
    | global
    | labelRecords
    | linage
    | record
    | recordingMode
    | valueOf
    | report
    )
    (--> .)  # TODO Handle skipped.
    .
end

def sdFileDescriptionEntry =
    SD fileName
   !( blockContains    # Supported by IBM Enterprise Cobol for z/OS.
    | dataRecords
    | labelRecords
    | record
    | recordingMode
    )
    (--> .)  # TODO Handle skipped.
    .
end

def blockContains =
    BLOCK [CONTAINS] integer [TO integer] [CHARACTERS | RECORDS]
end

def codeSet =
    CODE-SET [IS] alphabetName
end

def dataRecords =
    [DATA] (RECORD | RECORDS) [IS | ARE] (dataName)+
end

def labelRecords =
    LABEL (RECORD | RECORDS) [IS | ARE] (OMITTED | STANDARD | (dataName)+)
end

def linage =
    LINAGE [IS] (dataName | integer) [LINES]
    [footing]
    [linesAtTop]
    [linesAtBottom]
end

def footing =
    [WITH] FOOTING [AT] (dataName | integer)
end

def linesAtTop =
    [LINES] [AT] TOP (dataName | integer)
end

def linesAtBottom =
    [LINES] [AT] BOTTOM (dataName | integer)
end

def record =
    RECORD
    ( [CONTAINS] integer [TO integer] [CHARACTERS]
    | [IS] VARYING [IN] [SIZE]
      [[FROM] integer [TO integer] [CHARACTERS]]
      [DEPENDING [ON] fileName]
    )
end

def recordingMode =
    RECORDING [MODE] [IS] ( F | V | U | S )
end

def valueOf =
    VALUE OF (
      (IDENTIFICATION | ID | cobolWord) [IS] (dataName | literal)
    )+
end

# Based on http://www.helsinki.fi/atk/unix/dec_manuals/cobv27ua/cobrm_014.htm
def report =
    ( REPORT | REPORTS ) [IS | ARE] (reportName)+
end

def dataDescriptionEntry =
    ( dataDescriptionEntry_format1
    | dataDescriptionEntry_format2
    | dataDescriptionEntry_format3
    )
end

def dataDescriptionEntry_format1 =
    levelNumber [dataName]
    [redefines]
   !( blankWhenZero
    | external
    | global
    | justified
    | occurs
    | picture
    | sign
    | sync
    | usage
    | value
    )
    (--> .)  # TODO Handle skipped.
    .
end

def dataDescriptionEntry_format2 =
    66 dataName
    RENAMES dataName (qualifier)*
    [(THROUGH | THRU) dataName (qualifier)*]
    . 
end

def dataDescriptionEntry_format3 =
    88 cobolWord 
    ( VALUE [IS]
    | VALUES [ARE]
    )
    ( literal [(THROUGH | THRU) literal] [','] )+
    .
end

def redefines =
    REDEFINES cobolWord
end

def blankWhenZero =
    BLANK [WHEN] (ZERO |  ZEROS  |  ZEROES )
end

def external =
    [IS] EXTERNAL
end

def global =
    [IS] GLOBAL
end

def justified =
    (JUSTIFIED | JUST) [RIGHT]
end

def occurs =
    # TODO The "TO numeric" part should only occur when "DEPENDING ON" occurs.
    OCCURS integer [TO integer] [TIMES]
    [ DEPENDING [ON] dataName (qualifier)* ]
    ((ASCENDING | DESCENDING) [KEY] [IS] (dataName (qualifier)*)+)* 
    [INDEXED [BY] (indexName)+]
end

def picture =
    ( PIC | PICTURE ) [IS] pictureString
end

def sign =
    [SIGN [IS]] (LEADING | TRAILING) [SEPARATE [CHARACTER]]
end

def sync =
    (SYNCHRONIZED | SYNC) [LEFT | RIGHT]
end

def usage =
    [USAGE [IS]] (
      BINARY
    | COMPUTATIONAL
    | COMP
    | DISPLAY
    | INDEX
    | PACKED-DECIMAL
    | COMPUTATIONAL-1 
    | COMP-1 
    | COMPUTATIONAL-2 
    | COMP-2 
    | COMPUTATIONAL-3 
    | COMP-3 
    | COMPUTATIONAL-4 
    | COMP-4 
    | COMPUTATIONAL-5 
    | COMP-5
    | POINTER
    )
end

def value =
    VALUE [IS] literal
end

## #############################################################################
## PROCEDURE DIVISION .
## -----------------------------------------------------------------------------

# I have seen descriptions of the format for procedure divisions where if you
# use sections everything must be inside a section. That is, there can be no
# leading statements or paragraphs. This however conflicts with actual code I
# have seen. I therefore do not enforce this rule and accept leading statements
# and paragraphs.

def procedureDivision =
	PROCEDURE DIVISION [usingPhrase] [returningPhrase] .
	[declaratives]
    (sentence)*
    (paragraph)*
    (section)*
#	[--> divisionStart]
end

def usingPhrase =
    USING 
    (dataReference | dataValue)*
end

def dataReference = 
	[[BY] REFERENCE] dataName
end

def dataValue =
	[BY] VALUE dataName
end

def returningPhrase =
	RETURNING
	dataName
end

def declaratives =
    DECLARATIVES .
    (declarativeSection)+
    END DECLARATIVES .
end

def declarativeSection =
    sectionName SECTION .
    useStatement
    (paragraph)*
end

def useStatement =
    USE (--> .) .
end

def section =
    sectionName SECTION [segmentNumber] .
    (sentence)*
    (paragraph)*
end

def paragraph =
    paragraphName .
    (sentence)*
end

def sentence =
    ( statement (statement | continuationOfStatement)* [.]
    | copyStatement
    | replaceStatement
    | .
    )
end

def statement =
    ( addStatement
    | callStatement
    | cancelStatement
    | closeStatement
    | computeStatement
    | deleteStatement
    | divideStatement
    | entryStatement
    | evaluateStatement
    | execStatement
    | exitStatement
    | gobackStatement
    | goToStatement
    | ifStatement
    | moveStatement
    | multiplyStatement
    | openStatement
    | performStatement
    | readStatement
    | releaseStatement
    | returnStatement
    | rewriteStatement
    | searchStatement
    | startStatement
    | stopStatement
    | stringStatement
    | subtractStatement
    | unstringStatement
    | writeStatement
    | setStatement
    | initializeStatement
    | displayStatement
    | inspectStatement
    
    | verb
      [--> ( . | endOfStatement )]
    )
end

def continuationOfStatement (Token t) =
    ( t=eventPhrase 
      { warn(t, "Nested statement found out of line."); }
      statement

    | t=endOfStatementMarker
      { warn(t, "Loose end of statement."); }
    )
end

def nestedStatements =
    (statement)+
end

def eventPhrase (Token t) returns t =
    [NOT] [ON | AT]
    ( t=EXCEPTION
    | t=SIZE ERROR
    | t=OVERFLOW
    | t=INVALID [KEY]
    | t=END
    | t=END-OF-PAGE
    | t=EOP
    )
end

def endOfStatementMarker (Token t) returns t =
    ( t=END-ACCEPT
    | t=END-ADD
    | t=END-CALL
    | t=END-COMPUTE
    | t=END-DELETE
    | t=END-DIVIDE
    | t=END-EVALUATE
    | t=END-EXEC
    | t=END-IF
    | t=END-MULTIPLY
    | t=END-PERFORM
    | t=END-READ
    | t=END-RETURN
    | t=END-REWRITE
    | t=END-SEARCH
    | t=END-START
    | t=END-STRING
    | t=END-SUBTRACT
    | t=END-UNSTRING
    | t=END-WRITE
    )
end

def verb =
    ( ADD
    | CALL
    | CANCEL
    | CLOSE
    | DELETE
    | DIVIDE
    | ENTRY
    | EVALUATE
    | EXEC
    | EXIT
    | GOBACK
    | GO
    | IF
    | MOVE
    | MULTIPLY
    | OPEN
    | PERFORM
    | READ
    | RELEASE
    | RETURN
    | REWRITE
    | SEARCH
    | STOP
    | STRING
    | SUBTRACT
    | UNSTRING
    | WRITE
    | SET
    | INITIALIZE
    | DISPLAY
    | COMPUTE
    | INSPECT
    
    # Verbs for statements which have a skeletal implementation:
    | START

    # Verbs for statements which remain to be implemented:
    | ACCEPT
    | ALTER
    | CONTINUE
    | MERGE
    | SORT
    | USE
    
    # Following are verbs found in testsuite, not in documentation.
    | ENABLE
    | DISABLE
    | SEND
    | RECEIVE
    | PURGE
    | INITIATE
    | GENERATE
    | TERMINATE
    )
end

## #############################################################################
## ADD statement.
## -----------------------------------------------------------------------------

def addStatement =
    ADD ( addition_format1 | addition_format2 | addition_format3 )
    [[ON] SIZE ERROR nestedStatements]
    [NOT [ON] SIZE ERROR nestedStatements]
    [END-ADD]
end

def addition_format1 =
    (CORRESPONDING | CORR) identifier TO identifier [ROUNDED]
end

def addition_format2 =
    (identifier | literal)+
    [TO (identifier | literal)]
    GIVING (identifier [ROUNDED])+
end

def addition_format3 =
    (identifier | literal)+
    TO (identifier [ROUNDED])+
end

## #############################################################################
## CALL statement.
## -----------------------------------------------------------------------------

def callStatement =
    CALL programID
    [ callUsing ]

    [ # Call statement format 1.
      onOverflow
    
    | # Call statement format 2.
      onException
      [notOnException]

    | # Call statement format 2.
      notOnException
    ]

    [END-CALL]
end

def callUsing =
    USING (identifier)*
          ( [BY] REFERENCE (identifier | OMITTED)+
          | [BY] CONTENT (literal | identifier)+
          | [BY] VALUE (literal | identifier)+
          )*
end

def onOverflow =
    [ON] OVERFLOW nestedStatements
end

def onException =
    [ON] EXCEPTION nestedStatements
end

def notOnException =
    NOT [ON] EXCEPTION nestedStatements
end

def programID =
    (identifier | alphanumeric)
end

## #############################################################################
## CANCEL statement.
## -----------------------------------------------------------------------------

def cancelStatement =
    CANCEL (identifier | alphanumeric)+
end

## #############################################################################
## CLOSE statement.
## -----------------------------------------------------------------------------

def closeStatement =
    CLOSE (fileName
      [ [WITH] (NO REWIND | LOCK)
      | (REEL | UNIT) [[FOR] REMOVAL]
      | [FOR] REMOVAL
      ]
    )+
end

## #############################################################################
## COMPUTE statement.
## -----------------------------------------------------------------------------

def computeStatement =
    COMPUTE
    (identifier [ROUNDED])+
    ('=' | EQUAL)
    arithmeticExpression
    [[ON] SIZE ERROR nestedStatements]
    [NOT [ON] SIZE ERROR nestedStatements]
    [END-COMPUTE]
end

## #############################################################################
## DELETE statement.
## -----------------------------------------------------------------------------

def deleteStatement =
    DELETE fileName [RECORD]
    
    [INVALID [KEY] nestedStatements]
    [NOT INVALID [KEY] nestedStatements]
    
    [END-DELETE]
end

## #############################################################################
## DISPLAY statement.
## -----------------------------------------------------------------------------

def displayStatement =
	DISPLAY
	([','] (identifier | literal))+
	[uponClause]
	[withNoAdvancing]
end

def uponClause =
	UPON
	(mnemonicName | environmentName)
end

def withNoAdvancing =
	[WITH] NO ADVANCING
end

## #############################################################################
## DIVIDE statement.
## -----------------------------------------------------------------------------

def divideStatement =
    DIVIDE ( division_format1 | division_format2 | division_format3 )
    [[ON] SIZE ERROR nestedStatements]
    [NOT [ON] SIZE ERROR nestedStatements]
    [END-DIVIDE]
end

def division_format1 =
    (identifier | literal)
    (INTO | BY) (identifier | literal)
    GIVING identifier [ROUNDED]
    REMAINDER identifier
end

def division_format2 =
    (identifier | literal)
    (INTO | BY) (identifier | literal)
    GIVING (identifier [ROUNDED])+
end

def division_format3 =
    (identifier | literal)
    INTO (identifier [ROUNDED])+
end

## #############################################################################
## ENTRY statement.
## -----------------------------------------------------------------------------

def entryStatement =
    ENTRY alphanumeric [USING (dataName)+]
end

## #############################################################################
## EVALUATE statement.
## -----------------------------------------------------------------------------

def evaluateStatement =
    EVALUATE subject (ALSO subject)* 
    (when)+ 
    [whenOther]
    [END-EVALUATE]
end

def subject =
	(--> (WHEN | ALSO))
end


def when =
    ( WHEN object
      (ALSO object)*
    )+ 
    nestedStatements
end

def whenOther =
    WHEN OTHER
      nestedStatements
end

# Note: the order of the alternatives here is very important!
def object =
    ( ANY

    | rangeExpression

    | condition
    
    | [NOT] (
        identifier
      | literal
      | arithmeticExpression
      )
    | '(' object ')'
    )
end

def rangeExpression =
  [NOT] 
  ( identifier
  | literal
  | arithmeticExpression
  )
  ( THROUGH | THRU )
  ( identifier
  | literal
  | arithmeticExpression
  )
end


## #############################################################################
## EXEC statement.
## -----------------------------------------------------------------------------

def execStatement =
   ( execSQLStatement
   | execCICSStatement
     
   # This is a catch-all, which includes SQL and CICS statements which somehow
   # didn't match.
   | EXEC cobolWord
        [--> END-EXEC]
     END-EXEC
   )
end

# EXEC SQL support. ------------------------------------------------------------

def execSQLStatement =
   EXEC SQL 
     sqlStatement 
     [--> END-EXEC]
   END-EXEC
end

def sqlStatement =
   ( sqlInclude
   | sqlSelect
   | sqlInsert
   | sqlUpdate
   | sqlDelete
   )
end

def sqlInclude =
   INCLUDE textName
end

def sqlSelect =
   ( SELECT | DECLARE [--> SELECT] SELECT)
   [--> FROM] FROM [identifier '.'] tableName    
end

def sqlInsert =
   INSERT INTO [identifier '.'] tableName
end

def sqlUpdate =
   UPDATE [identifier '.'] tableName
end

def sqlDelete = 
   DELETE FROM [identifier '.'] tableName
end

def tableName =
    cobolWord
end

# EXEC CICS support. -----------------------------------------------------------

def execCICSStatement =
   EXEC CICS
        cicsStatement
        [--> END-EXEC]
     END-EXEC
end

def cicsStatement =
   ( cicsReadQ
   | cicsWriteQ
   | cicsDeleteQ 
   | cicsReadFile
   | cicsWriteFile 
   | cicsLink
   | cicsXctl
   | cicsLoad
   | cicsStart
   )
end

def dataArea =
   (literal | identifier)
end

def cicsReadQ =
   READQ 
   ( TS (QUEUE | QNAME) '(' queueName ')' 
     !( (SYSID|SYS) '(' cicsSysid ')'
      | (SET|INTO) '(' dataArea ')' [LENGTH cicsWaterInBrackets]
      | (ITEM cicsWaterInBrackets | NEXT)
      | NUMITEMS cicsWaterInBrackets
      )
   | TD QUEUE '(' (literal | identifier) ')' 
   )
end

def cicsWriteQ =
   WRITEQ 
   ( TS (QUEUE | QNAME) '(' queueName ')'
     !( (SYSID|SYS) '(' cicsSysid ')'
      | FROM '(' dataArea ')' [LENGTH cicsWaterInBrackets]
      | (NUMITEMS cicsWaterInBrackets | ITEM cicsWaterInBrackets [REWRITE])
      | NOSUSPEND
      | (MAIN|AUXILIARY)
      )
   | TD QUEUE '(' queueName ')'
   )
end

def cicsDeleteQ =
   DELETEQ (TS|TD) (QUEUE | QNAME) '(' queueName ')'
   [(SYSID|SYS) '(' cicsSysid ')']
end

def cicsReadFile =
   ( READ (FILE | DATASET) '(' fileName ')'
     !( (SYSID|SYS) '(' cicsSysid ')'
      | (SET|INTO) '(' dataArea ')' [LENGTH cicsWaterInBrackets]
      | RIDFLD cicsWaterInBrackets     [KEYLENGTH cicsWaterInBrackets [GENERIC]]
      | (GTEQ|EQUAL)
      | (UNCOMMITTED|CONSISTENT|REPEATABLE|UPDATE TOKEN cicsWaterInBrackets)
      | NOSUSPEND
      )
   | READNEXT (FILE|DATASET) '(' fileName ')'
     !( (SYSID|SYS) '(' cicsSysid ')'
      | (SET|INTO) '(' dataArea ')' [LENGTH cicsWaterInBrackets]
      | RIDFLD cicsWaterInBrackets     [KEYLENGTH cicsWaterInBrackets] 
      | (RBA|XRBA|RRN)
      | (UNCOMMITTED|CONSISTENT|REPEATABLE|UPDATE TOKEN cicsWaterInBrackets)
      | NOSUSPEND
      )
   )
end

def cicsWriteFile =
   WRITE (FILE | DATASET) '(' fileName ')'
   !( (SYSID|SYS) '(' cicsSysid ')'
    | FROM '(' dataArea ')' [LENGTH cicsWaterInBrackets]
    | RIDFLD cicsWaterInBrackets [KEYLENGTH cicsWaterInBrackets] 
    | (RBA|XRBA|RRN)
    | MASSINSERT
    | NOSUSPEND
    )
end

def cicsLink =
   LINK PROGRAM '(' programID ')'
   !( (SYSID|SYS) '(' cicsSysid ')'
    | COMMAREA '(' commareaName ')' [LENGTH cicsWaterInBrackets] [DATALENGTH cicsWaterInBrackets]
    | SYNCONRETURN
    | TRANSID cicsWaterInBrackets
    | INPUTMSG cicsWaterInBrackets [INPUTMSGLEN cicsWaterInBrackets]
    | CHANNEL cicsWaterInBrackets
    )
end

def cicsXctl =
   XCTL PROGRAM '(' programID ')'
   !( COMMAREA '(' commareaName ')' [LENGTH cicsWaterInBrackets] 
    | INPUTMSG cicsWaterInBrackets [INPUTMSGLEN cicsWaterInBrackets]
    | CHANNEL cicsWaterInBrackets
    )
end

def cicsLoad =
   LOAD PROGRAM '(' programID ')'
end

def cicsStart =
   START (TRANSID|TR) '(' transactionName ')'
end

def cicsSysid =
   (literal | identifier)
end

def queueName =
   (literal | identifier)
end

def transactionName =
   (literal | identifier)
end

def commareaName =
   (literal | identifier)
end

def cicsWaterInBrackets =
   '(' [--> ')'] ')'
end

## #############################################################################
## EXIT statement.
## -----------------------------------------------------------------------------

def exitStatement =
    EXIT [PROGRAM | PARAGRAPH]
end

## #############################################################################
## GOBACK statement.
## -----------------------------------------------------------------------------

def gobackStatement =
    GOBACK
end

## #############################################################################
## GO TO statement.
## -----------------------------------------------------------------------------

def goToStatement =
    GO [TO]
    [ procedureName
        [ (procedureName)*
          DEPENDING [ON] identifier
        ]
    ]
end

## #############################################################################
## IF statement.
## -----------------------------------------------------------------------------

def ifStatement =
    IF condition [THEN]
      ( nestedStatements
      | NEXT SENTENCE
      )
    [ELSE
      ( nestedStatements
      | NEXT SENTENCE
      )
    ]
    [END-IF]
end

## #############################################################################
## INITIALIZE statement.
## -----------------------------------------------------------------------------

def initializeStatement =
	INITIALIZE
	(identifier)+
	[replacingInitClause]
	[--> (. | endOfStatement)]
end

def replacingInitClause =
	REPLACING
	replacementTarget
	[DATA] BY
	(identifier | literal)
end

def replacementTarget =
	(ALPHABETIC 
	|ALPHANUMERIC
	|ALPHANUMERIC-EDITED
	|NATIONAL
	|NATIONAL-EDITED
	|NUMERIC
	|NUMERIC-EDITED
	|DBCS
	|EGCS)
end

## #############################################################################
## INSPECT statement.
## -----------------------------------------------------------------------------

def inspectStatement =
	INSPECT identifier

	( convertingPhrase

    | tallyingPhrase
      [replacingPhrase]
      
	| replacingPhrase
    )
end

def convertingPhrase =
	CONVERTING
	(identifier | literal)
	TO
	(identifier | literal)
	(locationPhrase)*
end

def tallyingPhrase =
	TALLYING
	( identifier FOR
	  ( tallyingCharactersPhrase
	  | tallyingAllLeadingPhrase
	  )*
	)*
end

def tallyingCharactersPhrase =
	CHARACTERS
	(locationPhrase)*
end

def tallyingAllLeadingPhrase =
	(ALL | LEADING)
	( (identifier -FOR | literal)
	  (locationPhrase)*
	)*
end

def replacingPhrase =
	REPLACING
	( replacingCharactersPhrase 
	| replacingAllLeadingFirstPhrase
	)*
end

def replacingCharactersPhrase =
	CHARACTERS BY
	(identifier | literal)
	(locationPhrase)*
end

def replacingAllLeadingFirstPhrase =
	(ALL | LEADING | FIRST)
	( (identifier | literal) BY (identifier | literal) (locationPhrase)* )*
end

def locationPhrase =
	(BEFORE | AFTER)
	[INITIAL]
	(identifier | literal)
end

## #############################################################################
## MOVE statement.
## -----------------------------------------------------------------------------

def moveStatement =
    MOVE 
      ( LENGTH [ OF ] identifier
      | [CORRESPONDING | CORR] identifier
      | literal
      )
    TO ([','] identifier)+
end

## #############################################################################
## MULTIPLY statement.
## -----------------------------------------------------------------------------

def multiplyStatement =
    MULTIPLY ( multiplication_format1 | multiplication_format2 )
    [[ON] SIZE ERROR nestedStatements]
    [NOT [ON] SIZE ERROR nestedStatements]
    [END-MULTIPLY]
end

# The order of these is important!

def multiplication_format1 =
    (identifier | literal)
    BY (identifier | literal)
    GIVING (identifier [ROUNDED])+
end

def multiplication_format2 =
    (identifier | literal)
    BY (identifier [ROUNDED])+
end

## #############################################################################
## OPEN statement.
## -----------------------------------------------------------------------------

def openStatement =
    OPEN
    ( INPUT (fileName [REVERSED | [WITH] NO REWIND])+
    | OUTPUT (fileName [[WITH] NO REWIND])+
    | I-O (fileName)+
    | EXTEND (fileName)+
    )+
end

## #############################################################################
## PERFORM statement.
## -----------------------------------------------------------------------------

# The order here is important! If you want to correctly recognize:
#   PERFORM 7 TIMES  ...
# Then you need to check in-line first. If not, the parser will understand the
# number as a procedureName (yes, 7 is a valid procedure name).
def performStatement =
    PERFORM 
    ( # "in-line"
      [ times | until | varying ]
      [ nestedStatements ]
      END-PERFORM

    | # "out-of-line"
      procedureName [(THROUGH | THRU) procedureName]
      [ times | until | varying ]
    )
end

def times =
    (identifier | integer) TIMES
end

def until =
    [testPosition]
    UNTIL condition
end

def testPosition =
	[WITH] TEST (BEFORE | AFTER)
end 

# The documentation also explicitly mentions indices. Matching these, however,
# requires tracking their definition in the data section. This is something we
# don't do. This doesn't matter that much, as indices are a degenerate form of
# identifiers, which we are able to match. So the catch is that while we do
# match indices it is up to the end-user to distinguish them from identifiers.
def varying =
    [[WITH] TEST (BEFORE | AFTER)]
    
    VARYING identifier
        FROM (literal | identifier)
        BY (literal | identifier)
        UNTIL condition
    
    (AFTER  identifier
        FROM (literal | identifier)
        BY (literal | identifier)
        UNTIL condition
    )*
end

## #############################################################################
## READ statement.
## -----------------------------------------------------------------------------

def readStatement =
    READ fileName [[WITH] NO LOCK] [NEXT | PREVIOUS] [RECORD] [INTO identifier]
    
    [KEY [IS] dataName]
    
    [[AT] END nestedStatements]
    [NOT [AT] END nestedStatements]
    
    [INVALID [KEY] nestedStatements]
    [NOT INVALID [KEY] nestedStatements]
    
    [END-READ]
end

## #############################################################################
## RELEASE statement.
## -----------------------------------------------------------------------------

def releaseStatement =
    RELEASE recordName [FROM identifier]
end

## #############################################################################
## RETURN statement.
## -----------------------------------------------------------------------------

def returnStatement =
    RETURN fileName [RECORD] [INTO identifier] 
    atEnd 
    [notAtEnd]
    [END-RETURN]
end

## #############################################################################
## REWRITE statement.
## -----------------------------------------------------------------------------

def rewriteStatement =
    REWRITE recordName [FROM identifier]
    
    [INVALID [KEY] nestedStatements]
    [NOT INVALID [KEY] nestedStatements]
    
    [END-REWRITE]
end

## #############################################################################
## SEARCH statement.
## -----------------------------------------------------------------------------

def searchStatement =
    SEARCH 
    ( ALL identifier
    | identifier [VARYING (identifier | indexName)]
    )
   
    [atEnd]
   
    ( WHEN condition
      ( nestedStatements
      | NEXT SENTENCE
      )
    )+ 
   
    [END-SEARCH]
end

def atEnd =
    [AT] END nestedStatements
end

def notAtEnd =
    NOT [AT] END nestedStatements
end

## #############################################################################
## SET statement.
## -----------------------------------------------------------------------------

def setStatement =
    SET
    (setFormat1
    | setFormat2
    | setFormat3
    )
    [--> (. | endOfStatement)]
end

def setFormat1 =
	(indexName | addressOfIdentifier | identifier)+
	TO
	(indexName | addressOfIdentifier | identifier | integer)
end

def setFormat2 =
	(mnemonicName)+
	TO
	(ON | OFF)
end

def setFormat3 =
	(identifier)+
	TO
	TRUE
end


## #############################################################################
## START statement.
## -----------------------------------------------------------------------------

# TODO So far a skeletal implementation only.
def startStatement =
    START
    ( -->
      ( [NOT] INVALID [KEY]
      | END-START
      | .
      | endOfStatement
      )
    )
    
    [INVALID [KEY] nestedStatements]
    [NOT INVALID [KEY] nestedStatements]
    
    [END-START]
end

## #############################################################################
## STOP statement.
## -----------------------------------------------------------------------------

def stopStatement =
    STOP (RUN | literal)
end

## #############################################################################
## STRING statement.
## -----------------------------------------------------------------------------

def stringStatement =
    STRING
    ( ( identifier | literal ) [DELIMITED [BY] (SIZE | identifier | literal)] )+
    INTO identifier [[WITH] POINTER identifier]
    [[ON] OVERFLOW nestedStatements]
    [NOT [ON] OVERFLOW nestedStatements]
    [END-STRING]
end

## #############################################################################
## SUBTRACT statement.
## -----------------------------------------------------------------------------

def subtractStatement =
    SUBTRACT ( subtraction_format1 | subtraction_format2 | subtraction_format3 )
    [[ON] SIZE ERROR nestedStatements]
    [NOT [ON] SIZE ERROR nestedStatements]
    [END-SUBTRACT]
end

def subtraction_format1 =
    (CORRESPONDING | CORR) identifier FROM identifier [ROUNDED]
end

def subtraction_format2 =
    (identifier | literal)+
    [FROM (identifier | literal)]
    GIVING (identifier [ROUNDED])+
end

def subtraction_format3 =
    (identifier | literal)+
    FROM (identifier [ROUNDED])+
end

## #############################################################################
## UNSTRING statement.
## -----------------------------------------------------------------------------

def unstringStatement =
    UNSTRING identifier
    
    [ DELIMITED [BY] [ALL] (identifier | literal)
      ( OR [ALL] (identifier | literal) )*
    ]
    
    INTO (
      identifier
      [DELIMITER [IN] identifier]
      [COUNT [IN] identifier]
    )+
    
    [[WITH] POINTER identifier]
    [TALLYING [IN] identifier]
    
    [[ON] OVERFLOW nestedStatements]
    [NOT [ON] OVERFLOW nestedStatements]
    [END-UNSTRING]
end

## #############################################################################
## WRITE statement.
## -----------------------------------------------------------------------------

def writeStatement =
    WRITE recordName [FROM identifier]
    
    [ (AFTER | BEFORE) [ADVANCING]
      ( (identifier | integer | ZERO) [LINE | LINES]
      | mnemonicName
      | PAGE
      )
    ]
    
    [[AT] (END-OF-PAGE | EOP) nestedStatements]
    [NOT [AT] (END-OF-PAGE | EOP) nestedStatements]
    
    [INVALID [KEY] nestedStatements]
    [NOT INVALID [KEY] nestedStatements]
    
    [END-WRITE]
end

## #############################################################################
## Controlling the compiler.
## -----------------------------------------------------------------------------

def copyStatement =
    COPY textName [ (OF | IN) libraryName ]
    [SUPPRESS]
    [copyReplacingPhrase]
    .
end

def copyReplacingPhrase =
	REPLACING
	(copyReplacementInstruction)+
end

def copyReplacementInstruction =
	copyOperandName BY copyOperandName
end

def copyOperandName =
	(pseudoLiteral | verb | literal | identifier | cobolWord)
end

def replaceStatement =
    REPLACE (--> .) .
end

## #############################################################################
## Lookaheads used for skipping.
## -----------------------------------------------------------------------------

# Division start
def divisionStart =
    ( IDENTIFICATION DIVISION
    | ENVIRONMENT DIVISION
    | DATA DIVISION
    | PROCEDURE DIVISION [usingPhrase] [returningPhrase]
    )
    .
end

# Start of section in data division.
def dataSectionStart =
    ( FILE
    | WORKING-STORAGE
    | LINKAGE
    | COMMUNICATION
    | REPORT
    ) SECTION .
end

# End of a (nested) statement.
def endOfStatement =
    ( verb

    | ELSE             # IF statement
    | WHEN             # SEARCH, EVALUATE statement

    | END-ACCEPT
    | END-ADD
    | END-CALL
    | END-COMPUTE
    | END-DELETE
    | END-DISPLAY
    | END-DIVIDE
    | END-EVALUATE
    | END-EXEC
    | END-IF
    | END-MULTIPLY
    | END-PERFORM
    | END-READ
    | END-RETURN
    | END-REWRITE
    | END-SEARCH
    | END-START
    | END-STRING
    | END-SUBTRACT
    | END-UNSTRING
    | END-WRITE

    | [NOT] [ON | AT]
      ( OVERFLOW       # CALL statement
      | EXCEPTION      # CALL statement
      | SIZE ERROR
      | INVALID [KEY]
      | END            # RETURN statement
      | END-OF-PAGE
      | EOP
      )
    )
end

## #############################################################################
## Identifiers.
## -----------------------------------------------------------------------------

# TODO Qualifiers, subscripts and reference modifiers.
# TODO FUNCTION format.

def identifier =
    ( identifier_format1
    | identifier_format2
    )
end

def identifier_format1 =
    FUNCTION functionName ['(' (argument [','])+ ')'] [referenceModifier]
end

def identifier_format2 =
    dataName (qualifier)* ['(' (subscript [','])+ ')'] [referenceModifier]
end

def addressOfIdentifier =
	ADDRESS OF identifier
end

def argument =
    ( arithmeticExpression
    | identifier
    | literal
    )
end

def qualifier =
    (IN | OF) dataName
end

def subscript =
    # The order is important here ! Relative and direct subscripts overlap
    # somewhat. A direct may be a simple dataName; a relative a dataName
    # followed by an offset. If we matched the direct first we would never
    # check for the offset.
    ( relativeSubscript
    | directSubscript
    )
end

def directSubscript = 
    ( integer
    | identifier
    | ALL
    )
end

def relativeSubscript =
    identifier ('+' | '-') integer
end

def referenceModifier =
    '(' arithmeticExpression ':' [arithmeticExpression] ')'
end

## #############################################################################
## Arithmetic expressions.
## -----------------------------------------------------------------------------

def arithmeticExpression =
    timesDiv (('+' | '-') timesDiv)*
end

def timesDiv =
    power (('*' | '/') power)*
end

def power =
    [('+' | '-')] basis ('**' basis)*
end

# TODO Check sources for use of ZERO in this case.
def basis =
    ( ZERO
    | identifier
    | numeric
    | '(' arithmeticExpression ')'
    )
end

## #############################################################################
## Conditions.
## -----------------------------------------------------------------------------

# TODO Conditions
def condition =
--> ( THEN             # IF statement
    | verb             # IF statement
    | NEXT SENTENCE    # IF statement
    | END-PERFORM      # PERFORM statement
    | AFTER            # PERFORM statement
    | WHEN             # EVALUATE statement
    | ALSO             # EVALUATE statement
    | .
    )
end

## #############################################################################
## Low level stuff.
## -----------------------------------------------------------------------------

# Program name.
#
# "[A] program-name can be specified either as a user-defined word or in an
# alphanumeric literal. Either way, program-name must follow the rules for
# forming a user-defined word. program-name cannot be a figurative constant.
# Any lowercase letters in the literal are folded to uppercase."
#
# Src: "COBOL for AIX, V3.1"
# http://publib.boulder.ibm.com/infocenter/comphelp/v101v121/index.jsp?topic=/com.ibm.aix.cbl.doc/PGandLR/ref/rlprg.htm
#
def programName =
	( cobolWord
	| alphanumeric
	)
end

# Data name.
def dataName =
	(cobolWord | FILLER | CURSOR)
end

# Section name.
def sectionName =
	( cobolWord
	| integer
	)
end

# Paragraph name.
def paragraphName =
	( cobolWord
	| integer
	)
end

# Procedure name.
def procedureName =
    ( cobolWord
    | integer
    )
    [ ( IN | OF ) cobolWord ]
end

# Segment number.
def segmentNumber =
    # TODO Should be two digits only. 
    integer
end

# TODO Arithmetic expression will (likely) capture all other cases as well. Can
# we disambiguate this further ? 
def operand =
	( arithmeticExpression
	| identifier
	| literal
	| indexName
	)
end

def conditionName =
	identifier
end 

def indexName =
    cobolWord
end

def className =
	cobolWord
end

def fileName =
    ( cobolWord
    | alphanumeric
    )
end

def computerName =
	cobolWord
end

def functionName =
    cobolWord
end

def textName =
    ( cobolWord
    | alphanumeric
    )
end

def libraryName =
    cobolWord
end

def recordName =
    identifier
end

def mnemonicName =
    cobolWord
end

def environmentName =
	(SYSIN
	|SYSIPT
	|SYSOUT
	|SYSLIST
	|SYSLST
	|SYSPUNCH
	|SYSPCH
	|CONSOLE
	|C01
	|C02
	|C03
	|C04
	|C05
	|C06
	|C07
	|C08
	|C09
	|C10
	|C11
	|C12
	|CSP
	|S01
	|S02
	|S03
	|S04
	|S05
	|AFP-5A)
end

def alphabetName =
    cobolWord
end

def reportName =
    cobolWord
end

def assignmentName =
    cobolWord
end

def literal =
    ( numeric
    | alphanumeric

    # According to my documentation a figurative constant can appear anywhere a
    # literal can, except for a few edge cases. I'll ignore the edge cases here.
    | figurativeConstant
    
    # TODO Correct ?
    | booleanLiteral
    )
end

def booleanLiteral =
	(TRUE | FALSE)
end

# TODO [ALL] symbolic-character
def figurativeConstant =
    ( ALL literal
    | [ALL]
      ( ZERO
      | ZEROS
      | ZEROES 
      | SPACE
      | SPACES 
      | HIGH-VALUE 
      | HIGH-VALUES 
      | LOW-VALUE 
      | LOW-VALUES 
      | QUOTE
      | QUOTES
      )
    | NULL
    | NULLS
    )
end

def numeric =
    ( integer
    | decimal
    | hexadecimal
    | LENGTH OF identifier	
    )
end
