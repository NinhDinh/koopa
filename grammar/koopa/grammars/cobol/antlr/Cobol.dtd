<!ELEMENT koopa (compilationGroup|copybook)>
<!ELEMENT compilationGroup (compilationUnit*)>
<!ELEMENT copybook (copybookHoldingData|copybookHoldingBehaviour)>
<!ELEMENT copybookHoldingData ((dataDescriptionEntry|specialNameStatement|(fileDescriptionEntry,recordDescriptionEntry*)|(selectStatement,t?)|copyStatement|replaceStatement|(execStatement,t?))+)>
<!ELEMENT copybookHoldingBehaviour (sentence*,paragraph*,section*)>
<!ELEMENT compilationUnit (identificationDivision,environmentDivision?,dataDivision?,(procedureDivision,compilationUnit*)?,(t+,programName,t)?)>
<!ELEMENT identificationDivision (t,t+,programName,(t?,((t,t?)|(t,t?)),t?)?,t?,water?)>
<!ELEMENT environmentDivision (t+,configurationSection?,ioSection?,water?)>
<!ELEMENT configurationSection (t+,(sourceComputerParagraph|objectComputerParagraph|specialNamesParagraph)*,water?)>
<!ELEMENT sourceComputerParagraph (t+,(computerName,withDebuggingMode?,t)?,water?)>
<!ELEMENT withDebuggingMode (t?,t,t)>
<!ELEMENT objectComputerParagraph (t+,(computerName,water?,t)?,water?)>
<!ELEMENT genericStringDef (alphanumeric*,(t,t)?,t?)>
<!ELEMENT specialNamesParagraph (t+,(copyStatement|specialNameStatement)*,t?,water?)>
<!ELEMENT specialNameStatement (decimalIsComma|currencySignIs|consoleIsCRT|cursorIs|crtStatusIs|numericSignIs|classIs|symbolicChars|alphabetIs|mnemonicClause)>
<!ELEMENT decimalIsComma (t,t?,t)>
<!ELEMENT currencySignIs (t,t?,t?,literal)>
<!ELEMENT consoleIsCRT (t,t?,t)>
<!ELEMENT cursorIs (t,t?,dataName)>
<!ELEMENT crtStatusIs (t+,dataName)>
<!ELEMENT numericSignIs (t+,t,(t,t?)?)>
<!ELEMENT classIs (t,identifier,t?,(literalRange|literal)+)>
<!ELEMENT literalRange (literal,t,literal)>
<!ELEMENT symbolicChars (t,t?,(literal+,t?,integer+)+,(t,identifier)?)>
<!ELEMENT alphabetIs (t?,identifier,t?,alphabetType)>
<!ELEMENT alphabetType (standard1AlphabetType|standard2AlphabetType|nativeAlphabetType|explicitAlphabetType|codeNameAlphabetType)>
<!ELEMENT standard1AlphabetType (t)>
<!ELEMENT standard2AlphabetType (t)>
<!ELEMENT nativeAlphabetType (t)>
<!ELEMENT explicitAlphabetType ((literalRange|literal),(t,(literalRange|literal))*)>
<!ELEMENT codeNameAlphabetType (cobolWord)>
<!ELEMENT mnemonicClause (t,t?,t)>
<!ELEMENT confParagraphStart (t,t)>
<!ELEMENT ioSection (t+,fileControlParagraph,ioControlParagraph?,water?)>
<!ELEMENT fileControlParagraph (t+,(selectStatement|copyStatement)*)>
<!ELEMENT selectStatement (selectClause,assignClause,(organizationIsSequentialClause|fileStatusClause)*,water?,t)>
<!ELEMENT selectClause (t,t?,fileName)>
<!ELEMENT assignClause (t,(assignUsingClause|assignToClause))>
<!ELEMENT assignUsingClause (t,dataName)>
<!ELEMENT assignToClause (t?,assignmentName)>
<!ELEMENT organizationIsSequentialClause ((t,t?)?,t)>
<!ELEMENT fileStatusClause (t?,t,t?,dataName,dataName?)>
<!ELEMENT ioControlParagraph (t+,water?)>
<!ELEMENT environmentSectionStart (t+,t)>
<!ELEMENT dataDivision (t+,fileSection?,workingStorageSection?,localStorageSection?,linkageSection?,communicationSection?,reportSection?)>
<!ELEMENT fileSection (t+,(copyStatement|(fileDescriptionEntry,recordDescriptionEntry*))*,water?)>
<!ELEMENT recordDescriptionEntry (dataDescriptionEntry|copyStatement)>
<!ELEMENT localStorageSection (t+,(recordDescriptionEntry|replaceStatement|(execStatement,t?))*)>
<!ELEMENT workingStorageSection (t+,(recordDescriptionEntry|replaceStatement|(execStatement,t?))*)>
<!ELEMENT linkageSection (t+,(recordDescriptionEntry|replaceStatement|(execStatement,t?))*)>
<!ELEMENT communicationSection (t+,water?)>
<!ELEMENT reportSection (t+,water?)>
<!ELEMENT fileDescriptionEntry (fdFileDescriptionEntry|sdFileDescriptionEntry)>
<!ELEMENT fdFileDescriptionEntry (t,fileName,(blockContains|codeSet|dataRecords|external|global|labelRecords|linage|record|recordingMode|valueOf|report)*,water?,t)>
<!ELEMENT sdFileDescriptionEntry (t,fileName,(blockContains|dataRecords|labelRecords|record|recordingMode)*,water?,t)>
<!ELEMENT blockContains (t,t?,integer,(t,integer)?,t?)>
<!ELEMENT codeSet (t,t?,alphabetName)>
<!ELEMENT dataRecords (t?,t,t?,dataName+)>
<!ELEMENT labelRecords (t+,(t|dataName+))>
<!ELEMENT linage (t,t?,(dataName|integer),t?,footing?,linesAtTop?,linesAtBottom?)>
<!ELEMENT footing (t?,t,t?,(dataName|integer))>
<!ELEMENT linesAtTop (t?,t?,t,(dataName|integer))>
<!ELEMENT linesAtBottom (t?,t?,t,(dataName|integer))>
<!ELEMENT record (t,((t?,integer,(t,integer)?,t?)|(t?,t,t?,t?,(t?,integer,(t,integer)?,t?)?,(t,t?,fileName)?)))>
<!ELEMENT recordingMode (t,t?,t?,t)>
<!ELEMENT valueOf (t+,((t|cobolWord),t?,(dataName|literal))+)>
<!ELEMENT report (t,t?,reportName+)>
<!ELEMENT dataDescriptionEntry (dataDescriptionEntry_format1|dataDescriptionEntry_format2|dataDescriptionEntry_format3|constantDescriptionEntry)>
<!ELEMENT dataDescriptionEntry_format1 (levelNumber,dataName?,redefines?,(blankWhenZero|external|global|justified|occurs|picture|sign|sync|usage|value|based)*,water?,t)>
<!ELEMENT dataDescriptionEntry_format2 (t,dataName,t,dataName,qualifier*,(t,dataName,qualifier*)?,t)>
<!ELEMENT dataDescriptionEntry_format3 (t,cobolWord,((t,t?)|(t,t?)),(literal,(t,literal)?)+,t)>
<!ELEMENT constantDescriptionEntry (t,cobolWord,value?,t)>
<!ELEMENT redefines (t,cobolWord)>
<!ELEMENT blankWhenZero (t,t?,t)>
<!ELEMENT external (t?,t)>
<!ELEMENT global (t?,t)>
<!ELEMENT justified (t,t?)>
<!ELEMENT occurs (t,integer,(t,integer)?,t?,(t,t?,dataName,qualifier*)?,(t,t?,t?,(dataName,qualifier*)+)*,(t,t?,indexName+)?)>
<!ELEMENT picture (t,t?,pictureString)>
<!ELEMENT sign ((t,t?)?,t,(t,t?)?)>
<!ELEMENT sync (t,t?)>
<!ELEMENT usage ((t,t?)?,t)>
<!ELEMENT value (t,t?,literal)>
<!ELEMENT based (t)>
<!ELEMENT procedureDivision (t+,usingOrChainingPhrase?,returningPhrase?,t,declaratives?,sentence*,paragraph*,section*)>
<!ELEMENT usingOrChainingPhrase (t,(dataReference|dataValue)*)>
<!ELEMENT dataReference ((t?,t)?,dataName)>
<!ELEMENT dataValue (t?,t,dataName)>
<!ELEMENT returningPhrase (t,dataName)>
<!ELEMENT declaratives (t+,declarativeSection+,t+,t)>
<!ELEMENT declarativeSection (sectionName,t+,useStatement,paragraph*)>
<!ELEMENT section (sectionName,t,segmentNumber?,t,sentence*,paragraph*)>
<!ELEMENT paragraph (paragraphName,t,sentence*)>
<!ELEMENT sentence ((statement,(statement|continuationOfStatement)*,t)|copyStatement|replaceStatement|useStatement)>
<!ELEMENT statement (addStatement|callStatement|cancelStatement|closeStatement|computeStatement|deleteStatement|divideStatement|entryStatement|evaluateStatement|execStatement|exitStatement|gobackStatement|goToStatement|ifStatement|moveStatement|multiplyStatement|openStatement|performStatement|readStatement|releaseStatement|returnStatement|rewriteStatement|searchStatement|startStatement|stopStatement|stringStatement|subtractStatement|unstringStatement|writeStatement|setStatement|initializeStatement|displayStatement|inspectStatement|allocateStatement|freeStatement|(verb,water?))>
<!ELEMENT subStatementMarker (t|(t,t)|t|(t,t?,t)|(t?,t)|(t,t?,t)|(t?,t)|(t,t?,t)|(t?,t)|(t,t?,t)|(t?,t)|(t,t?,t)|(t,t?,t)|(t?,t)|(t?,t))>
<!ELEMENT continuationOfStatement ((eventPhrase,statement)|endOfStatementMarker)>
<!ELEMENT nestedStatements (statement+)>
<!ELEMENT eventPhrase (t?,t?,(t|(t,t)|t|(t,t?)|t))>
<!ELEMENT endOfStatementMarker (t)>
<!ELEMENT verb (t)>
<!ELEMENT addStatement (t,(addition_format1|addition_format2|addition_format3),(t+,nestedStatements)?,(t,t+,nestedStatements)?,t?)>
<!ELEMENT addition_format1 (t,identifier,t,identifier,t?)>
<!ELEMENT addition_format2 ((identifier|literal)+,(t,(identifier|literal))?,t,(identifier,t?)+)>
<!ELEMENT addition_format3 ((identifier|literal)+,t,(identifier,t?)+)>
<!ELEMENT allocateStatement (t,((arithmeticExpression,t)|identifier),t?,(t,identifier)?)>
<!ELEMENT callStatement (t,programID,callUsing?,callGivingOrReturning?,(onOverflow|(onException,notOnException?)|notOnException)?,t?)>
<!ELEMENT callUsing (t,(literal|identifier)*,((t?,t,(identifier|t)+)|(t?,t,(literal|identifier)+)|(t?,t,(literal|identifier)+))*)>
<!ELEMENT callGivingOrReturning (t,t?,identifier)>
<!ELEMENT onOverflow (t?,t,nestedStatements)>
<!ELEMENT onException (t?,t,nestedStatements)>
<!ELEMENT notOnException (t,t?,t,nestedStatements)>
<!ELEMENT programID (identifier|alphanumeric)>
<!ELEMENT cancelStatement (t,(identifier|alphanumeric)+)>
<!ELEMENT closeStatement (t,(fileName,((t?,((t,t)|t))|(t,(t?,t)?)|(t?,t))?)+)>
<!ELEMENT computeStatement (t,(identifier,t?)+,t,arithmeticExpression,(t+,nestedStatements)?,(t,t+,nestedStatements)?,t?)>
<!ELEMENT deleteStatement (t,fileName,t?,(t,t?,nestedStatements)?,(t+,nestedStatements)?,t?)>
<!ELEMENT displayStatement (t,(displayUponFormat|displayTerminalFormat|displayScreenFormat|water?),t?)>
<!ELEMENT displayUponFormat ((identifier|literal)+,uponClause,withNoAdvancing?)>
<!ELEMENT uponClause (t,(environmentName|mnemonicName))>
<!ELEMENT withNoAdvancing (t?,t,t)>
<!ELEMENT displayTerminalFormat (((identifier|literal),(t,(identifier|literal))?,displayTerminalMods?)+)>
<!ELEMENT displayTerminalMods ((dtBellMod|dtBlinkMod|dtControlMod|dtConvertMod|dtEraseMod|dtLightingMod|dtPositioningMod|dtModeBlockMod|dtReverseMod|dtSizeMod)+)>
<!ELEMENT dtBellMod (t?,t)>
<!ELEMENT dtBlinkMod (t?,t)>
<!ELEMENT dtControlMod (t?,t,(identifier|literal))>
<!ELEMENT dtConvertMod (t?,t)>
<!ELEMENT dtEraseMod (t?,t,t)>
<!ELEMENT dtLightingMod (t?,t)>
<!ELEMENT dtPositioningMod (t?,(dtAtPositioning|dtLineColPositioning))>
<!ELEMENT dtModeBlockMod (t?,t,t?,t)>
<!ELEMENT dtReverseMod (t?,t)>
<!ELEMENT dtSizeMod (t?,t,(identifier|literal))>
<!ELEMENT dtAtPositioning (t,(identifier|literal))>
<!ELEMENT dtLineColPositioning (t?,(dtLinePos|dtColPos)+)>
<!ELEMENT dtLinePos (t,(identifier|literal))>
<!ELEMENT dtColPos (t,(identifier|literal))>
<!ELEMENT displayScreenFormat (((identifier|literal),(screenLineColClause|screenAtClause))+)>
<!ELEMENT screenAtClause (t,(identifier|integer))>
<!ELEMENT screenLineColClause (t?,((t,t?,(identifier|integer))|(t,t?,(identifier|integer)))+)>
<!ELEMENT divideStatement (t,(division_format1|division_format2|division_format3),(t+,nestedStatements)?,(t,t+,nestedStatements)?,t?)>
<!ELEMENT division_format1 ((identifier|literal),t,(identifier|literal),t,identifier,t?,t,identifier)>
<!ELEMENT division_format2 ((identifier|literal),t,(identifier|literal),t,(identifier,t?)+)>
<!ELEMENT division_format3 ((identifier|literal),t,(identifier,t?)+)>
<!ELEMENT entryStatement (t,alphanumeric,(t,dataName+)?)>
<!ELEMENT evaluateStatement (t,subject,(t,subject)*,when+,whenOther?,t?)>
<!ELEMENT subject (condition|identifier|arithmeticExpression|literal)>
<!ELEMENT when ((t,object,(t,object)*)+,nestedStatements)>
<!ELEMENT whenOther (t+,nestedStatements)>
<!ELEMENT object (t|rangeExpression|t|condition|(t?,(identifier|literal|arithmeticExpression))|(t,object,t))>
<!ELEMENT rangeExpression (t?,(identifier|literal|arithmeticExpression),t,(identifier|literal|arithmeticExpression))>
<!ELEMENT execStatement (execSQLStatement|execCICSStatement|(t,cobolWord,water?,t))>
<!ELEMENT execSQLStatement (t+,sqlStatement,water?,t)>
<!ELEMENT sqlStatement (sqlInclude|sqlSelect|sqlInsert|sqlUpdate|sqlDelete)>
<!ELEMENT sqlInclude (t,textName)>
<!ELEMENT sqlSelect ((t|(t,water?,t)),water?,t,(identifier,t)?,tableName)>
<!ELEMENT sqlInsert (t+,(identifier,t)?,tableName)>
<!ELEMENT sqlUpdate (t,(identifier,t)?,tableName)>
<!ELEMENT sqlDelete (t+,(identifier,t)?,tableName)>
<!ELEMENT tableName (cobolWord)>
<!ELEMENT execCICSStatement (t+,cicsStatement,water?,t)>
<!ELEMENT cicsStatement (cicsReadQ|cicsWriteQ|cicsDeleteQ|cicsReadFile|cicsWriteFile|cicsLink|cicsXctl|cicsLoad|cicsStart)>
<!ELEMENT dataArea (literal|identifier)>
<!ELEMENT cicsReadQ (t,((t+,queueName,t,((t+,cicsSysid,t)|(t+,dataArea,t,(t,cicsWaterInBrackets)?)|((t,cicsWaterInBrackets)|t)|(t,cicsWaterInBrackets))*)|(t+,(literal|identifier),t)))>
<!ELEMENT cicsWriteQ (t,((t+,queueName,t,((t+,cicsSysid,t)|(t+,dataArea,t,(t,cicsWaterInBrackets)?)|((t,cicsWaterInBrackets)|(t,cicsWaterInBrackets,t?))|t)*)|(t+,queueName,t)))>
<!ELEMENT cicsDeleteQ (t+,queueName,t,(t+,cicsSysid,t)?)>
<!ELEMENT cicsReadFile ((t+,fileName,t,((t+,cicsSysid,t)|(t+,dataArea,t,(t,cicsWaterInBrackets)?)|(t,cicsWaterInBrackets,(t,cicsWaterInBrackets,t?)?)|(t)|(t|(t+,cicsWaterInBrackets))|t)*)|(t+,fileName,t,((t+,cicsSysid,t)|(t+,dataArea,t,(t,cicsWaterInBrackets)?)|(t,cicsWaterInBrackets,(t,cicsWaterInBrackets)?)|(t)|(t|(t+,cicsWaterInBrackets))|t)*))>
<!ELEMENT cicsWriteFile (t+,fileName,t,((t+,cicsSysid,t)|(t+,dataArea,t,(t,cicsWaterInBrackets)?)|(t,cicsWaterInBrackets,(t,cicsWaterInBrackets)?)|(t)|t)*)>
<!ELEMENT cicsLink (t+,programID,t,((t+,cicsSysid,t)|(t+,commareaName,t,(t,cicsWaterInBrackets)?,(t,cicsWaterInBrackets)?)|t|(t,cicsWaterInBrackets)|(t,cicsWaterInBrackets,(t,cicsWaterInBrackets)?)|(t,cicsWaterInBrackets))*)>
<!ELEMENT cicsXctl (t+,programID,t,((t+,commareaName,t,(t,cicsWaterInBrackets)?)|(t,cicsWaterInBrackets,(t,cicsWaterInBrackets)?)|(t,cicsWaterInBrackets))*)>
<!ELEMENT cicsLoad (t+,programID,t)>
<!ELEMENT cicsStart (t+,transactionName,t)>
<!ELEMENT cicsSysid (literal|identifier)>
<!ELEMENT queueName (literal|identifier)>
<!ELEMENT transactionName (literal|identifier)>
<!ELEMENT commareaName (literal|identifier)>
<!ELEMENT cicsWaterInBrackets (t,water?,t)>
<!ELEMENT exitStatement (t,(t|(t,t?))?)>
<!ELEMENT freeStatement (t,((t,t?)?,identifier)+)>
<!ELEMENT gobackStatement (t)>
<!ELEMENT goToStatement (t,t?,(procedureName,(procedureName*,t,t?,identifier)?)?)>
<!ELEMENT ifStatement (t,condition,t?,(nestedStatements|(t,t)),(t,(nestedStatements|(t,t)))?,t?)>
<!ELEMENT initializeStatement (t,identifier+,replacingInitClause?,water?)>
<!ELEMENT replacingInitClause (t,replacementTarget,t?,t,(identifier|literal))>
<!ELEMENT replacementTarget (t)>
<!ELEMENT inspectStatement (t,identifier,(convertingPhrase|(tallyingPhrase,replacingPhrase?)|replacingPhrase))>
<!ELEMENT convertingPhrase (t,(identifier|literal),t,(identifier|literal),locationPhrase*)>
<!ELEMENT tallyingPhrase (t,(identifier,t,(tallyingCharactersPhrase|tallyingAllLeadingOrTrailingPhrase)*)*)>
<!ELEMENT tallyingCharactersPhrase (t,locationPhrase*)>
<!ELEMENT tallyingAllLeadingOrTrailingPhrase (t,((identifier|literal),locationPhrase*)*)>
<!ELEMENT replacingPhrase (t,(replacingCharactersPhrase|replacingAllLeadingFirstOrTrailingPhrase)*)>
<!ELEMENT replacingCharactersPhrase (t+,(identifier|literal),locationPhrase*)>
<!ELEMENT replacingAllLeadingFirstOrTrailingPhrase (t,((identifier|literal),t,(identifier|literal),locationPhrase*)*)>
<!ELEMENT locationPhrase (t,t?,(identifier|literal))>
<!ELEMENT moveStatement (t,((t,t?,identifier)|(t?,identifier)|literal),t,identifier+)>
<!ELEMENT multiplyStatement (t,(multiplication_format1|multiplication_format2),(t+,nestedStatements)?,(t,t+,nestedStatements)?,t?)>
<!ELEMENT multiplication_format1 ((identifier|literal),t,(identifier|literal),t,(identifier,t?)+)>
<!ELEMENT multiplication_format2 ((identifier|literal),t,(identifier,t?)+)>
<!ELEMENT openStatement (t,((t,(fileName,(t|(t?,t,t))?)+)|(t,(fileName,(t?,t,t)?)+)|(t,fileName+)|(t,fileName+))+)>
<!ELEMENT performStatement (t,(((times|until|varying)?,nestedStatements?,t)|(procedureName,(t,procedureName)?,(times|until|varying)?)))>
<!ELEMENT times ((identifier|integer),t)>
<!ELEMENT until (testPosition?,t,condition)>
<!ELEMENT testPosition (t?,t,t)>
<!ELEMENT varying ((t?,t,t)?,t,identifier,t,(literal|identifier),t,(literal|identifier),t,condition,(t,identifier,t,(literal|identifier),t,(literal|identifier),t,condition)*)>
<!ELEMENT readStatement (t,fileName,(t?,t?,t)?,t?,t?,(t,identifier)?,(t,t?,dataName)?,(t?,t,nestedStatements)?,(t,t?,t,nestedStatements)?,(t,t?,nestedStatements)?,(t+,nestedStatements)?,t?)>
<!ELEMENT releaseStatement (t,recordName,(t,identifier)?)>
<!ELEMENT returnStatement (t,fileName,t?,(t,identifier)?,atEnd,notAtEnd?,t?)>
<!ELEMENT rewriteStatement (t,recordName,(t,identifier)?,(t,t?,nestedStatements)?,(t+,nestedStatements)?,t?)>
<!ELEMENT searchStatement (t,((t,identifier)|(identifier,(t,(identifier|indexName))?)),atEnd?,(t,condition,(nestedStatements|(t,t)))+,t?)>
<!ELEMENT atEnd (t?,t,nestedStatements)>
<!ELEMENT notAtEnd (t,t?,t,nestedStatements)>
<!ELEMENT setStatement (t,(setFormat1|setFormat2|setFormat3),water?)>
<!ELEMENT setFormat1 ((indexName|identifier)+,t,(indexName|identifier|integer))>
<!ELEMENT setFormat2 (mnemonicName+,t,t)>
<!ELEMENT setFormat3 (identifier+,t,t)>
<!ELEMENT startStatement (t,fileName,keyModifier?,sizeModifier?,whileKeyModifier?,(t,t?,nestedStatements)?,(t+,nestedStatements)?,t?)>
<!ELEMENT keyModifier (t,t?,(generalRelationOp|t),identifier,(t,identifier)*)>
<!ELEMENT sizeModifier (t?,t,(identifier|integer))>
<!ELEMENT whileKeyModifier (t,(t,t?)?,negationOp?,t,likeMods*,(identifier|literal))>
<!ELEMENT likeMods (trimmedRight|trimmedLeft|caseSensitive|caseInsensitive)>
<!ELEMENT trimmedRight (t,t)>
<!ELEMENT trimmedLeft (t,t)>
<!ELEMENT caseSensitive (t)>
<!ELEMENT caseInsensitive (t)>
<!ELEMENT stopStatement (t,(t|literal))>
<!ELEMENT stringStatement (t,((identifier|literal),(t,t?,(t|identifier|literal))?)+,t,identifier,(t?,t,identifier)?,(t?,t,nestedStatements)?,(t,t?,t,nestedStatements)?,t?)>
<!ELEMENT subtractStatement (t,(subtraction_format1|subtraction_format2|subtraction_format3),(t+,nestedStatements)?,(t,t+,nestedStatements)?,t?)>
<!ELEMENT subtraction_format1 (t,identifier,t,identifier,t?)>
<!ELEMENT subtraction_format2 ((identifier|literal)+,(t,(identifier|literal))?,t,(identifier,t?)+)>
<!ELEMENT subtraction_format3 ((identifier|literal)+,t,(identifier,t?)+)>
<!ELEMENT unstringStatement (t,identifier,(t,t?,t?,(identifier|literal),(t,t?,(identifier|literal))*)?,t,(identifier,(t,t?,identifier)?,(t,t?,identifier)?)+,(t?,t,identifier)?,(t,t?,identifier)?,(t?,t,nestedStatements)?,(t,t?,t,nestedStatements)?,t?)>
<!ELEMENT useStatement (t,(errorDeclarative|debugOnAllDeclarative|debugDeclarative|labelDeclarative),t)>
<!ELEMENT errorDeclarative (t?,t,t+,(t|fileName)*)>
<!ELEMENT debugDeclarative (t?,t,t?,(procedureName|fileName|((t,(t,t)?)?,identifier))*)>
<!ELEMENT debugOnAllDeclarative (t?,t,t?,t,t)>
<!ELEMENT labelDeclarative (t?,t,t+,(t|fileName)*)>
<!ELEMENT writeStatement (t,recordName,(t,identifier)?,(t,t?,(((identifier|integer|t),t?)|mnemonicName|t))?,(t?,t,nestedStatements)?,(t,t?,t,nestedStatements)?,(t,t?,nestedStatements)?,(t+,nestedStatements)?,t?)>
<!ELEMENT copyStatement (t,textName,(t,libraryName)?,t?,copyReplacingPhrase?,t)>
<!ELEMENT copyReplacingPhrase (t,copyReplacementInstruction+)>
<!ELEMENT copyReplacementInstruction (copyOperandName,t,copyOperandName)>
<!ELEMENT copyOperandName (pseudoLiteral|verb|literal|identifier|cobolWord)>
<!ELEMENT replaceStatement (t,water?,t)>
<!ELEMENT divisionStart (((t,t)|(t,t)|(t,t)|(t+,usingOrChainingPhrase?,returningPhrase?)),t)>
<!ELEMENT dataSectionStart (t+,t)>
<!ELEMENT endOfStatement (verb|t|(t?,t?,(t|(t,t)|(t,t?)|t)))>
<!ELEMENT identifier (identifier_format1|identifier_format2|dataAddressIdentifier)>
<!ELEMENT identifier_format1 (t,functionName,(t,argument+,t)?,referenceModifier?)>
<!ELEMENT identifier_format2 (dataName,qualifier*,(t,subscript+,t)?,referenceModifier?)>
<!ELEMENT dataAddressIdentifier (t,t?,identifier)>
<!ELEMENT argument (arithmeticExpression|identifier|literal)>
<!ELEMENT qualifier (t,dataName)>
<!ELEMENT subscript (relativeSubscript|directSubscript)>
<!ELEMENT directSubscript (integer|identifier|t)>
<!ELEMENT relativeSubscript (identifier,t,integer)>
<!ELEMENT referenceModifier (t,arithmeticExpression,t,arithmeticExpression?,t)>
<!ELEMENT arithmeticExpression (summand,(signDef,summand)*)>
<!ELEMENT signDef (t)>
<!ELEMENT summand (factor,(t,factor)*)>
<!ELEMENT factor (signDef?,atomicExpression,(t,atomicExpression)*)>
<!ELEMENT atomicExpression (t|identifier|numeric|(t,arithmeticExpression,t))>
<!ELEMENT condition ((primaryCondition|(negationOp?,t,condition,t)),(conditionalRelationOP,(primaryCondition|(negationOp?,t,condition,t)))*)>
<!ELEMENT primaryCondition (negationOp?,primaryCondDef)>
<!ELEMENT primaryCondDef (booleanLiteral|(classPrimaryCondition,(conditionalRelationOP,negationOp?,classSecondaryCondition)*)|signPrimaryCondition|(generalPrimaryCondition,(conditionalRelationOP,negationOp?,generalSecondaryCondition)*)|(monoElemPrimaryCondition,(t?,negationOp?,monoElemPrimaryCondition)*))>
<!ELEMENT generalPrimaryCondition (operand,generalRelationOp,operand)>
<!ELEMENT signPrimaryCondition ((arithmeticExpression|identifier),t?,negationOp?,signType)>
<!ELEMENT signType (t)>
<!ELEMENT monoElemPrimaryCondition (t?,(conditionName|className))>
<!ELEMENT classPrimaryCondition (identifier,t?,negationOp?,classType)>
<!ELEMENT classType (t)>
<!ELEMENT generalSecondaryCondition (generalRelationOp?,operand)>
<!ELEMENT classSecondaryCondition (t?,negationOp?,classType)>
<!ELEMENT conditionalRelationOP (t)>
<!ELEMENT generalRelationOp (t?,(greaterOrEqualOp|lessOrEqualOp|greaterThanOp|notGreaterThanOp|lessThanOp|notLessThanOp|equalToOp|notEqualToOp))>
<!ELEMENT negationOp (t)>
<!ELEMENT greaterThanOp ((t,t?)|t)>
<!ELEMENT notGreaterThanOp (t,((t,t?)|t))>
<!ELEMENT lessThanOp ((t,t?)|t)>
<!ELEMENT notLessThanOp (t,((t,t?)|t))>
<!ELEMENT equalToOp ((t,t?)|t)>
<!ELEMENT notEqualToOp (t,((t,t?)|t))>
<!ELEMENT greaterOrEqualOp ((t,t+)|t)>
<!ELEMENT lessOrEqualOp ((t,t+)|t)>
<!ELEMENT programName (cobolWord|alphanumeric)>
<!ELEMENT dataName (cobolWord|t)>
<!ELEMENT sectionName (cobolWord|integer)>
<!ELEMENT paragraphName (cobolWord|integer)>
<!ELEMENT procedureName ((cobolWord|integer),(t,cobolWord)?)>
<!ELEMENT segmentNumber (integer)>
<!ELEMENT operand (arithmeticExpression|identifier|literal|indexName)>
<!ELEMENT conditionName (identifier)>
<!ELEMENT indexName (cobolWord)>
<!ELEMENT className (cobolWord)>
<!ELEMENT fileName (cobolWord|alphanumeric)>
<!ELEMENT computerName (cobolWord)>
<!ELEMENT functionName (cobolWord)>
<!ELEMENT textName (cobolWord|alphanumeric)>
<!ELEMENT libraryName (cobolWord)>
<!ELEMENT recordName (identifier)>
<!ELEMENT mnemonicName (cobolWord|identifier)>
<!ELEMENT environmentName (t)>
<!ELEMENT alphabetName (cobolWord)>
<!ELEMENT reportName (cobolWord)>
<!ELEMENT assignmentName (cobolWord|literal)>
<!ELEMENT literal (numeric|alphanumeric|figurativeConstant|booleanLiteral)>
<!ELEMENT booleanLiteral (t)>
<!ELEMENT figurativeConstant ((t,literal)|(t?,t)|t)>
<!ELEMENT numeric (integer|decimal|hexadecimal|(t+,identifier))>
<!ELEMENT cobolWord (t)>
<!ELEMENT integer (t)>
<!ELEMENT decimal (t)>
<!ELEMENT alphanumeric (t)>
<!ELEMENT pictureString (t*)>
<!ELEMENT levelNumber (t)>
<!ELEMENT pseudoLiteral (t)>
<!ELEMENT water (t*)>
<!ELEMENT t (#PCDATA)>
