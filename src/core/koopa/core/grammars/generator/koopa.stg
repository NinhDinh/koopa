group CSS;

koopa(name, extending, date, package, imports, reserved, rule, support_code) ::= <<
package $package$;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import koopa.core.data.Token;
import koopa.core.data.markers.Start;
import koopa.core.parsers.combinators.Block;
import koopa.core.grammars.KoopaGrammar;
import koopa.core.parsers.Parse;
import koopa.core.parsers.ParserCombinator;
import koopa.core.parsers.FutureParser;
import koopa.core.parsers.Stream;

import static koopa.core.grammars.combinators.Opt.NOSKIP;

$if(imports)$
$imports$

$endif$
public class $name$Grammar extends $extending$Grammar {
    public $name$Grammar() {
    }
    
    // ========================================================
    // Compiled grammar rules. These were generated from the
    // grammar.
    // --------------------------------------------------------

    $rule; separator="\n\n"$

    $if(support_code)$
    // ========================================================
    // Code provided by the user.
    // --------------------------------------------------------

    $support_code$$endif$
}
>>

rule(publik, name, body) ::= <<
// ========================================================
// $name$
// ........................................................

private ParserCombinator $name$Parser = null;

$if(publik)$
public final Start $name$ = Start.on(getNamespace(), "$name$");

public ParserCombinator $name$() {

$else$
private ParserCombinator $name$() {

$endif$
    if ($name$Parser == null) {
       FutureParser future = scoped("$name$", $publik$);
       $name$Parser = future;
       future.setParser(
           $body$
       );
    }

    return $name$Parser;
}
>>

returning(name) ::= <<returning("$name$")>>

sequence(step) ::= <<sequence(
    $step; separator=",\n"$
)
>>

bind(type, name) ::= <<$type$ $name$ = ($type$) parse.getStack().getScope().getValue("$name$");>>

unbind(name) ::= <<parse.getStack().getScope().setValue("$name$", $name$);>>

apply(bind, native_code, unbind) ::= <<apply(new Block() {
    public void apply(Parse parse) {
        $bind; separator="\n"$
        $native_code$
        $unbind; separator="\n"$
    }
})>>

token(text) ::= <<token("$text$")>>

literal(text) ::= <<literal("$text$")>>

call(name) ::= <<$name$()>>

star(body) ::= <<star(
    $body$
)>>

plus(body) ::= <<plus(
    $body$
)>>

choice(step) ::= <<choice(
    $step; separator=",\n"$
)>>

optional(body) ::= <<optional(
    $body$
)>>

skipto(body) ::= <<skipto(
    $body$
)>>

permuted(choice) ::= <<permuted(
    $choice; separator=",\n"$
)>>

assign(name, value) ::= <<assign("$name$", $value$)>>

not(body) ::= <<not(
    $body$
)>>


tag(text) ::= <<tagged($text$)>>

any() ::= <<any()>>

opt(option, body) ::= <<opt($option$,
    $body$
)>>

limit(target, limiter) ::= <<limited(
    $target$,
    $limiter$
)>>

as(name, body) ::= <<as("$name$",
    $body$
)>>

dispatched(keys, rules) ::= <<dispatched(
    new String[]{
      "$keys; separator="\",\n\""$"
    },
    new ParserCombinator[]{
      $rules; separator=",\n"$
    }
)>>
