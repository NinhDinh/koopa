package koopa.core.data;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * This is the main data item generated by Koopa. They represent pieces of text,
 * and can carry some metadata in the form of tags.
 * <p>
 * Tags themselves can be anything; though we recommend using enums.
 * <p>
 * <b>Trying to keep this class immutable.</b>
 */
public class Token implements Data {

	private final String text;
	private final List<Range> ranges;
	private final Set<Object> tags;

	private final Replaced replaced;

	/**
	 * Creates a new token from the given text, boundaries and tags.
	 * <p>
	 * Start and end positions should belong to the same resource. I.e.
	 * <code>start.getResourceName()</code> and
	 * <code>(end.getResourceName())</code> are both null, or are equal.
	 */
	public Token(String text, Position start, Position end, Object... tags) {
		assert (start != null);
		assert (end != null);
		assert (start.getResourceName() == null
				&& end.getResourceName() == null || start.getResourceName() != null
				&& start.getResourceName().equals(end.getResourceName()));

		this.text = text;

		List<Range> ranges = new ArrayList<Range>(1);
		ranges.add(new Range(start, end));

		this.ranges = Collections.unmodifiableList(ranges);
		this.tags = Collections.unmodifiableSet(new HashSet<Object>(Arrays
				.asList(tags)));

		this.replaced = null;
	}

	/**
	 * <b>NOTE</b> This is package scoped on purpose. Intended for use by
	 * {@linkplain Tokens} only.
	 */
	Token(String text, List<Range> ranges, Set<Object> tags, Replaced replacing) {
		assert (ranges != null);
		assert (ranges.size() > 0);

		this.text = text;

		this.ranges = Collections.unmodifiableList(ranges);
		this.tags = Collections.unmodifiableSet(tags);

		this.replaced = replacing;
	}

	/**
	 * Creates a new token which is equivalent to the composition of the given
	 * ones, except for their tags.
	 * <p>
	 * <b>The tags of the original tokens are not aggregated.</b> Instead you
	 * can specify whatever tags the new token should have as extra parameters.
	 * <p>
	 * The {@linkplain Range}s of the original tokens, however, do get
	 * aggregated into the new one.
	 * <p>
	 * The new token will not be seen as replacing some other token, despite
	 * what any of the given tokens may say.
	 * <p>
	 * <b>NOTE</b> This is package scoped on purpose. Please use the
	 * {@linkplain Tokens#join(List, Object...)} method instead.
	 */
	Token(List<Token> tokens, Object... tags) {
		StringBuffer buffer = new StringBuffer();

		for (Token token : tokens)
			buffer.append(token.getText());

		this.text = buffer.toString();

		List<Range> ranges = new ArrayList<Range>();
		for (Token token : tokens)
			ranges.addAll(token.ranges);

		assert (ranges.size() > 0);

		this.ranges = Collections.unmodifiableList(ranges);
		this.tags = Collections.unmodifiableSet(new HashSet<Object>(Arrays
				.asList(tags)));

		this.replaced = null;
	}

	/**
	 * Create a copy of one token, and register the copy as being a replacement
	 * for another one.
	 */
	private Token(Token token, Replaced replacing) {
		assert (token != null);
		assert (replacing != null);

		this.text = token.text;
		this.ranges = token.ranges;
		this.tags = token.tags;
		this.replaced = replacing;
	}

	public String getText() {
		return this.text;
	}

	public char charAt(int index) {
		return text.charAt(index);
	}

	public int getLength() {
		return text.length();
	}

	public Position getStart() {
		return ranges.get(0).getStart();
	}

	public Position getEnd() {
		return ranges.get(ranges.size() - 1).getEnd();
	}

	public Set<Object> getTags() {
		return tags;
	}

	public boolean hasTag(Object tag) {
		return tags.contains(tag);
	}

	/**
	 * Whether or not this token has <b>all</b> given tags.
	 */
	public boolean hasTags(Object... tags) {
		for (Object tag : tags)
			if (!hasTag(tag))
				return false;

		return true;
	}

	/**
	 * Whether or not this token has <b>any</b> of the given tags.
	 */
	public boolean hasAnyTag(Object... tags) {
		for (Object tag : tags)
			if (hasTag(tag))
				return true;

		return false;
	}

	public int tagCount() {
		return tags.size();
	}

	public List<Range> getRanges() {
		return ranges;
	}

	/**
	 * Creates a new token which is a copy of this one, with the addition of the
	 * given tags. If there are no tags given, or they are all already there,
	 * returns <code>this</code> instead.
	 */
	public Token withTags(Object... additionalTags) {
		if (additionalTags.length == 0)
			return this;

		if (hasTags(additionalTags))
			return this;

		Set<Object> newTags = new HashSet<Object>(tags);
		newTags.addAll(Arrays.asList(additionalTags));
		return new Token(text, ranges, newTags, replaced);
	}

	/**
	 * Creates a new token which is a copy of this one, with the exception of
	 * the given tags. If there are no tags given, or none of them are found
	 * here, returns <code>this</code> instead.
	 */
	public Token withoutTags(Object... theseTags) {
		if (theseTags.length == 0)
			return this;

		if (!hasAnyTag(theseTags))
			return this;

		Set<Object> newTags = new HashSet<Object>(tags);
		newTags.removeAll(Arrays.asList(theseTags));
		return new Token(text, ranges, newTags, replaced);
	}

	/**
	 * Creates a new token which is a copy of this one, minus one tag (if
	 * present), and with the addition of the other.
	 */
	public Token replacingTag(Object oldTag, Object newTag) {
		Set<Object> newTags = new HashSet<Object>(tags);
		newTags.remove(oldTag);
		newTags.add(newTag);
		return new Token(text, ranges, newTags, replaced);
	}

	/**
	 * Creates a copy of this token, while linking it to another one by saying
	 * that this token replaces it, either completely or in part.
	 */
	public Token asReplacing(Replaced replacing) {
		if (replacing == null)
			return this;
		else
			return new Token(this, replacing);
	}

	public Replaced getReplaced() {
		return replaced;
	}

	public boolean isReplacement() {
		return replaced != null;
	}

	@Override
	public String toString() {
		String s = null;
		if (replaced == null)
			s = "[" + getStart() + "|" + text + "|" + getEnd() + "]";
		else
			s = "{" + getStart() + "|" + text + "|" + getEnd() + "}";

		if (!tags.isEmpty())
			for (Object tag : tags)
				s += " @" + tag;

		return s;
	}
}
