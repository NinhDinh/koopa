grammar Cobol extends CobolBase.

## Micro Focus COBOL Language Reference
## http://documentation.microfocus.com/help/index.jsp?nav=%2F3_9_4_1

## #############################################################################
## Top level definitions.
## -----------------------------------------------------------------------------

# Compilation group.
def compilationGroup =
    (compilerDirective | sourceUnit)*
    
    [eof]
end

# Copybook. This is just a guess at the likely suspect(s).
def copybook =
    ( (sourceUnit)+
    | copybookHoldingData
    | copybookHoldingBehaviour
    )
    
    [eof]
end

def copybookHoldingData =
    ( constantEntry
    | dataDescriptionEntry
    | specialNameStatement
    | fileDescriptionEntry (recordDescriptionEntry)*
    | selectStatement [.]
    | copyStatement
    | replaceStatement
    | execStatement [.]
    )+
end

def copybookHoldingBehaviour =
    (sentence)*
    (paragraph)*
    (section)*
    (statement)*
end


## #############################################################################
## Compilation units
## -----------------------------------------------------------------------------

def sourceUnit =
    ( programPrototype                 # STD.BK
    | functionPrototype                # STD.BK
    | programDefinition                # STD.BK
    | functionDefinition               # STD.BK
    | classDefinition                  # STD.BK
    | interfaceDefinition              # STD.BK
    | methodDefinition                 # TODO Correct ? STD.BK does not show it...
    
    | callPrototypeDefinition          # MF
    | delegateDefinition               # MF
    | enumDefinition                   # MF
    | iteratorDefinition               # MF
    | enumDefinition                   # MF
    | operatorDefinition               # MF
    | valueTypeDefinition              # MF
    )
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Program prototype.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def programPrototype =
    ( [(ID | IDENTIFICATION) DIVISION .]
      programPrototypeIdParagraph
      [optionsParagraph]
    ) %as identificationDivision
    
    [environmentDivision]
    [dataDivision]
    [procedureDivision]
    END PROGRAM name .
end

def programPrototypeIdParagraph =
    PROGRAM-ID [.] name [AS literal] [IS] PROTOTYPE [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Function prototype.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def functionPrototype =
    ( [(ID | IDENTIFICATION) DIVISION .]
      functionPrototypeIdParagraph
      [optionsParagraph]
    ) %as identificationDivision

    [environmentDivision]
    [dataDivision]
    [procedureDivision]
    END FUNCTION name .
end

def functionPrototypeIdParagraph =
    FUNCTION-ID [.] name [AS literal] [IS] PROTOTYPE [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Program definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def programDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      programIdParagraph
      [replaceStatement]                         # SM208A.CBL
      [optionsParagraph]
      [metadata]                                 # Found in the testsuite.
    ) %as identificationDivision
    
    [environmentDivision]
    [dataDivision]
    [procedureDivision (programDefinition %as sourceUnit)*]
    [END PROGRAM programName .]
end

def programIdParagraph =
    PROGRAM-ID [.] programName [AS literal]
      [[IS] !( COMMON | (INITIAL | RECURSIVE) ) [PROGRAM]] [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Function definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def functionDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      functionIdParagraph
      [optionsParagraph]
    ) %as identificationDivision
    
    [environmentDivision]
    [dataDivision]
    [procedureDivision]
    END FUNCTION name .
end

def functionIdParagraph =
    FUNCTION-ID [.] name [AS literal] [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Class definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def classDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      classIdParagraph
      [optionsParagraph]
    ) %as identificationDivision
    
    [environmentDivision]
    [factoryDefinition]
    [instanceDefinition]
    END CLASS name .
end

def classIdParagraph =
    CLASS-ID [.] name [ AS literal ]
      [ INHERITS [FROM] (typeSpecifier)+ ]
      [ [IS] STATIC ]
      [ [IS] (PARTIAL | FINAL | ABSTRACT)+ ]
      [ [IS] (PUBLIC | INTERNAL) ]
      [ attributeClause ]
      [ IMPLEMENTS (typeSpecifier)+ ]
      [ USING (parameterName)+ ] [.]
end

def attributeClause =
    ( ATTRIBUTE attributeName '(' (NAME propertyName '=' propertyValue | parameterName)* ')'
    | CUSTOM-ATTRIBUTE IS className [ '(' (propertyName '=' propertyValue | parameterName)* ')' ]
    )+
end

def factoryDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      factoryParagraph
      [optionsParagraph]
    ) %as identificationDivision
    
    [environmentDivision]
    [dataDivision]
    [procedureDivision]
    END FACTORY .
end

def factoryParagraph =
    FACTORY [.] [IMPLEMENTS (name)+ .]
end

def instanceDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      objectParagraph
      [optionsParagraph]
    ) %as identificationDivision
    
    [environmentDivision]
    [dataDivision]
    [procedureDivision]
    END OBJECT .
end

def objectParagraph =
    OBJECT [.] [IMPLEMENTS (name)+ [.]]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Interface definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def interfaceDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      interfaceIdParagraph
      [optionsParagraph]
    ) %as identificationDivision
    
    [environmentDivision]
    [procedureDivision]
    END INTERFACE name .
end

def interfaceIdParagraph =
    INTERFACE-ID [.] name [AS literal]
      [INHERITS [FROM] (name)+]
      [USING [FROM] (name)+]
      [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Method definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def methodDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      methodIdParagraph
      [optionsParagraph]
    ) %as identificationDivision
    
    [environmentDivision]
    [dataDivision]
    [procedureDivision]
    END METHOD [name] .
end

def methodIdParagraph =
    METHOD-ID [.] 
      ( (GET | SET) PROPERTY name
      | name [AS literal]
      )
      [OVERRIDE] [[IS] FINAL] [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Call prototype definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Cfr.
# * https://supportline.microfocus.com/Documentation/books/sx51/prcall.htm
# * http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.studee60ux%2FHRLHLHEXAM02.html
#
# I'm guessing at the overall structure. The docs I found only show the 
# variation on the program id paragraph.

def callPrototypeDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      callPrototypeIdParagraph
      [optionsParagraph]
    ) %as identificationDivision
    
    [environmentDivision]
    [dataDivision]
    [procedureDivision]
    [END PROGRAM programName .]
end

def callPrototypeIdParagraph =
    PROGRAM-ID [.] programName [IS] EXTERNAL [PROGRAM] [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Delegate definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Cfr. http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.studee60ux%2FGUID-DA75663F-6357-4064-8112-C87E7457DE51.html

def delegateDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      delegateIdParagraph
    ) %as identificationDivision
    
    procedureDivisionHeader
    END DELEGATE .
end

def delegateIdParagraph =
    DELEGATE-ID [.] delegateName [ AS literal ]
    [ [IS] (PUBLIC | PRIVATE | PROTECTED | INTERNAL)+ ]
    [ attributeClause ]
    [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Enum definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def enumDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      enumIdParagraph
    ) %as identificationDivision
    
    [ --> (END ENUM .) ]
    END ENUM .
end

def enumIdParagraph =
    ENUM-ID [.] enumName [ AS literal ]
    [ [IS] (PUBLIC | PRIVATE | PROTECTED | INTERNAL)+ ]
    [ attributeClause ]
    [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Iterator definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Cfr. http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.studee60ux%2FGUID-FFC2F800-AB92-4E3A-89BF-7078E064C3B3.html

def iteratorDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      iteratorIdParagraph
    ) %as identificationDivision
    
    [ --> (END ITERATOR .) ]
    END ITERATOR .
end

def iteratorIdParagraph =
    ITERATOR-ID [.] iteratorName [ AS literal ]
    [ [IS] (PUBLIC | PRIVATE | PROTECTED | INTERNAL)+ ]
    [ attributeClause ]
    [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Operator definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Cfr. http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.studee60ux%2FGUID-FFC2F800-AB92-4E3A-89BF-7078E064C3B3.html

def operatorDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      operatorIdParagraph
    ) %as identificationDivision
    
    [ --> (END ENUM .) ]
    END OPERATOR .
end

def operatorIdParagraph =
    OPERATOR-ID [.]
    ( '=' [EXTENSION]
    | '<>'
    | '>='
    | '>'
    | '<='
    | '<'
    | '+'
    | '-'
    | '*'
    | '/'
    | B-AND
    | B-OR
    | B-XOR
    | B-NOT
    | B-LEFT
    | B-RIGHT
    | IMPLICIT
    | EXPLICIT
    )
    [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Value type definition.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Cfr. http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.studee60ux%2FGUID-FFC2F800-AB92-4E3A-89BF-7078E064C3B3.html

def valueTypeDefinition =
    ( [(ID | IDENTIFICATION) DIVISION .]
      valueTypeIdParagraph
    ) %as identificationDivision
    
    [ --> (END ENUM .) ]
    END VALUETYPE .
end

def valueTypeIdParagraph =
    VALUETYPE-ID [.] valuetypeName [ AS literal ]
    [ [IS] (FINAL | PARTIAL | ABSTRACT) ]
    [ [IS] (PUBLIC | INTERNAL) ]
    [ attributeClause ]
    [ IMPLEMENTS (interfaceName)+ ]
    [.]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def endMarker =
    END 
    ( CLASS name                  # STD.BK
    | FACTORY                     # STD.BK
    | FUNCTION name               # STD.BK
    | INTERFACE name              # STD.BK
    | METHOD [name]               # STD.BK
    | OBJECT                      # STD.BK
    | PROGRAM programName         # STD.BK
    
    | DELEGATE name               # *.NET
    | ENUM name                   # *.NET *JVM
    | OPERATOR [name]             # *.NET *JVM
    | STATIC                      # *.NET *JVM
    | VALUETYPE name              # *.NET *JVM
    ) .
end


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Options paragraph.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def optionsParagraph =
    OPTIONS .
    [arithmeticClause]
    [defaultRoundedClause]
    [entryConventionClause]
    [intermediateRoundingClause] .
end

def arithmeticClause =
    ARITHMETIC [IS] (NATIVE | STANDARD | STANDARD-BINARY | STANDARD-DECIMAL)
end

def defaultRoundedClause =
    DEFAULT ROUNDED [MODE] [IS]
    ( AWAY-FROM-ZERO
    | NEAREST-AWAY-FROM-ZERO
    | NEAREST-EVEN
    | NEAREST-TOWARD-ZERO
    | PROHIBITED
    | TOWARD-GREATER
    | TOWARD-LESSER
    | TRUNCATION
    )
end

def entryConventionClause =
    ENTRY-CONVENTION [IS] (COBOL | name)
end

def intermediateRoundingClause =
    INTERMEDIATE ROUNDING [IS] 
    ( NEAREST-AWAY-FROM-ZERO
    | NEAREST-EVEN
    | PROHIBITED
    | TRUNCATION
    )
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# This stuff is present in the testsuite. The best description I found for it
# is here: http://supportline.microfocus.com/documentation/books/sx20books/lrpdfx.htm
def metadata =
    ( AUTHOR .        [commentEntry]
    | INSTALLATION .  [commentEntry]
    | DATE-WRITTEN .  [commentEntry]
    | DATE-COMPILED . [commentEntry]
    | SECURITY .      [commentEntry]
    | REMARKS .       [commentEntry]
    )+
    [--> (paragraphStart | sectionStart | divisionStart)]
end


## #############################################################################
## ENVIRONMENT DIVISION .
## -----------------------------------------------------------------------------

def environmentDivision =
	( ENVIRONMENT DIVISION .
      [environmentDivisionBody]
      
    # *MF: First division header is optional.
      
    | environmentDivisionBody
    
    | configurationSectionBody
      [ioSection]
      [--> (paragraphStart | sectionStart | divisionStart)]
      
    | ioSectionBody
      [configurationSection]
      [--> (paragraphStart | sectionStart | divisionStart)]
    )
end

def environmentDivisionBody =
	( configurationSection
	| ioSection
	| objectSection
    )+
	[--> (paragraphStart | sectionStart | divisionStart)]
end

# Refs:
# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDF201.html

## #############################################################################
## CONFIGURATION SECTION
## -----------------------------------------------------------------------------

def configurationSection =
	CONFIGURATION SECTION .
	[ configurationSectionBody ]
end

def configurationSectionBody =
	( sourceComputerParagraph
	| objectComputerParagraph
	| specialNamesParagraph
    | repositoryParagraph
    | constraintsParagraph          # *.NET *JVM
    | classAttributesParagraph      # *.NET *JVM
    | assemblyAttributesParagraph   # *.NET *JVM
    )+
	[--> (paragraphStart | sectionStart | divisionStart)]
end

def sourceComputerParagraph =
	SOURCE-COMPUTER .
	[computerName [withDebuggingMode] .]
	[--> (paragraphStart | sectionStart | divisionStart)]
end

def withDebuggingMode =
	[WITH] DEBUGGING MODE
end

def objectComputerParagraph =
	OBJECT-COMPUTER .
	[computerName [--> .] .]
	[--> (paragraphStart | sectionStart | divisionStart)]
end

# TODO: CONSTRAINTS.

def constraintsParagraph =
    CONSTRAINTS.
    [--> (paragraphStart | sectionStart | divisionStart)]
end

# TODO: CLASS-ATTRIBUTES.

def classAttributesParagraph =
    CLASS-ATTRIBUTES.
    [--> (paragraphStart | sectionStart | divisionStart)]
end

# TODO: ASSEMBLY-ATTRIBUTES.

def assemblyAttributesParagraph =
    ASSEMBLY-ATTRIBUTES.
    [--> (paragraphStart | sectionStart | divisionStart)]
end

def genericStringDef =
	(alphanumeric)*
	[WITH DEBUGGING]
	[.]
end

## ###############################################################################
## SPECIAL-NAMES paragraph.
## -----------------------------------------------------------------------------

def specialNamesParagraph =
	SPECIAL-NAMES .
	( specialNameStatement
    | copyStatement
    )*
	[.]
	[--> (paragraphStart | sectionStart | divisionStart)]
end

def specialNameStatement =
    ( consoleIsCRT
	| alphabetIs
    | symbolicChars
    | classIs
    | localeIs
    | currencySignIs
    | decimalIsComma
    | numericSignIs
    | callConvention
    | cursorIs
    | crtStatusIs
    | xmlSchemaIs
    | screenControlIs
    | eventStatusIs
	| cobolSwitch IS mnemonicName ((ON | OFF) [STATUS] [IS] conditionName)*
	| cobolDevice IS mnemonicName
    )
end

def consoleIsCRT =
	CONSOLE [IS] CRT
end

def cobolDevice =
    ( SYSIN
    | SYSIPT
    | SYSOUT
    | SYSLIST
    | SYSLST
    | SYSPCH
    | SYSPUNCH
    | CONSOLE
    | TAB
    | PRINTER
    | FORMFEED
    | COMMAND-LINE
    | ARGUMENT-NUMBER
    | ENVIRONMENT-NAME
    | ENVIRONMENT-VALUE
    | SYSERR
    # Printer channels:
    | C01 | C02 | C03 | C04 | C05 | C06
    | C07 | C08 | C09 | C10 | C11 | C12
    # Select punch pockets:
    | S01 | S02 | S03 | S04 | S05
    # Suppress spacing:
    | CSP
    # TODO: One-character non-numeric literal:
    | alphanumericLiteral
    # TODO: based on NC220M; find matching documentation.
    | cobolWord
    )
end

def cobolSwitch =
    ( SWITCH-0 | SWITCH-1 | SWITCH-2
    | SWITCH-3 | SWITCH-4 | SWITCH-5
    | SWITCH-6 | SWITCH-7 | SWITCH-8
    )
end

def alphabetIs =
	ALPHABET identifier [IS] alphabetType
end

def alphabetType =
	( standard1AlphabetType
	| standard2AlphabetType
	| nativeAlphabetType
    | asciiAlphabetType
    | ebcdicAlphabetType
	| explicitAlphabetType
	| codeNameAlphabetType
	)
end

def standard1AlphabetType =
	STANDARD-1
end

def standard2AlphabetType =
	STANDARD-2
end

def nativeAlphabetType =
	NATIVE
end

def asciiAlphabetType =
    ASCII
end

def ebcdicAlphabetType =
    EBCDIC
end

def explicitAlphabetType =
	(literalRange | literal)
	(ALSO (literalRange | literal))*
end

def codeNameAlphabetType =
	cobolWord
end

def literalRange =
	literal (THROUGH | THRU) literal
end

def symbolicChars =
	SYMBOLIC [CHARACTER | CHARACTERS] ( (literal)+ [IS | ARE] (integer)+ )+ [IN identifier]
end

def classIs =
	CLASS identifier [IS] (literalRange | literal)+
end

def localeIs =
    LOCALE identifier [IS] identifier
end

def currencySignIs =
	CURRENCY [SIGN] [IS] literal
end

def decimalIsComma =
	DECIMAL-POINT [IS] COMMA
end

def numericSignIs =
	NUMERIC SIGN [IS] (LEADING | TRAILING) [SEPARATE [CHARACTER]]
end

def callConvention =
    CALL-CONVENTION integer [IS] mnemonicName
end

def cursorIs =
	CURSOR [IS] dataName
end

def crtStatusIs =
	CRT STATUS [IS] dataName
end

def xmlSchemaIs =
    XML-SCHEMA identifier [IS] (dataName | literal)
end

def screenControlIs =
    SCREEN CONTROL [IS] identifier
end

def eventStatusIs =
    EVENT STATUS [IS] identifier
end

## ###############################################################################
## REPOSITORY paragraph.
## -----------------------------------------------------------------------------

def repositoryParagraph =
    REPOSITORY .
    [
        ( classSpecifier
        | interfaceSpecifier
        | programSpecifier
        | propertySpecifier
        | functionSpecifier
        | delegateSpecifier
        | enumSpecifier
        )+
    . ]
end

def classSpecifier =
    CLASS className [AS literal] [EXPANDS className USING (className | interfaceName)]
end

def interfaceSpecifier =
    INTERFACE interfaceName [AS literal] [EXPANDS interfaceName USING (className | interfaceName)]
end

def programSpecifier =
    PROGRAM programName [AS literal]
end

def propertySpecifier =
    PROPERTY propertyName [AS literal]
end

def functionSpecifier =
    FUNCTION
    ( (ALL | functionName) INTRINSIC
    | functionName [AS literal]
    )
end

def delegateSpecifier =
    DELEGATE delegateName [AS literal]
end

def enumSpecifier =
    ENUM enumName [AS literal]
end

## ###############################################################################
## Input-Output Section
## -----------------------------------------------------------------------------

def ioSection =
	INPUT-OUTPUT SECTION .
	[ ioSectionBody ]
end

def ioSectionBody =
	( fileControlParagraph
	| ioControlParagraph
    )+
	[--> (paragraphStart | sectionStart | divisionStart)]
end

# TODO only skeletal implementation of this paragraph until now...
# http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.help.windows%2Fhtml%2Flhpdf209.htm

def fileControlParagraph =
	FILE-CONTROL .
	[fileControlEntry]
end

def fileControlEntry =
    ( selectStatement
    | copyStatement
    )+
end

## #############################################################################
## SELECT statement.
## -----------------------------------------------------------------------------

def selectStatement = 
    selectClause
    assignClause
    ![ organizationClause
     | collationClause
     | recordDelimiterClause
     | reserveClause
     | accessModeClause
     | lockModeClause
     | relativeKeyClause
     | recordKeyClause
     | (alternateRecordKeyClause)+
     | fileStatusClause
     | sharingClause
     | paddingClause
     ]
#    [--> .]
	.
end

def selectClause =
	SELECT
	[OPTIONAL | NOT OPTIONAL]
	fileName
end

def assignClause =
	ASSIGN (assignUsingClause | assignToClause)
end

def assignUsingClause =
	USING dataName
end

def assignToClause =
	[TO] [EXTERNAL | DYNAMIC] (diskClause | literal | name)
end

def diskClause =
    ( DISK FROM dataName
    | LINE ADVANCING [FILE] (dataName | literal)+
    | [MULTIPLE] (REEL | UNIT) [FILE] (dataName | literal)+
    | [DISK] FILE (dataName | literal)+
    | (DISK | PRINTER) DISPLAY
    | (DISK | KEYBOARD | DISPLAY | PRINTER | PRINTER-1) (dataName | literal)*
    )
end

def collationClause =
    COLLATING [SEQUENCE] [IS] alphabetName
end

def recordDelimiterClause =
    RECORD DELIMITER [IS] ( STANDARD-1 | alphanumericLiteral )
end

def reserveClause =
    RESERVE (integer | NO) [ALTERNATE] [AREA | AREAS]
end

def organizationClause =
	[ ORGANIZATION [IS] ]
    [ LINE | RECORD BINARY | RECORD | BINARY ]
	( SEQUENTIAL | RELATIVE | INDEXED )
end

def accessModeClause =
    ACCESS [MODE] [IS]
    ( SEQUENTIAL
    | RANDOM
    | DYNAMIC
    | EXCLUSIVE
    | MANUAL [lockModeWithClause]
    | AUTOMATIC [lockModeWithClause]
    )
end

def lockModeClause =
    LOCK [MODE] [IS]
    ( EXCLUSIVE
    | MANUAL [lockModeWithClause]
    | AUTOMATIC [lockModeWithClause]
    )
end

def lockModeWithClause =
    [WITH]
    ( ROLLBACK
    | LOCK ON [MULTIPLE] (RECORD | RECORDS)
    )
end

def relativeKeyClause =
    RELATIVE [KEY] [IS] recordKeyDefinition
end

def recordKeyClause =
    RECORD [KEY] [IS] recordKeyDefinition
        [passwordClause]
end

def alternateRecordKeyClause =
    ALTERNATE [RECORD] [KEY] [IS] recordKeyDefinition
        ![ passwordClause
         | suppressClause
         | [WITH] DUPLICATES
         ]
end

def recordKeyDefinition =
    ( (literal | identifier) ('=' | SOURCE [IS]) (dataName)+
    | dataName
    )
end

def fileStatusClause =
	[FILE | SORT] STATUS [IS] dataName [dataName]
end

def passwordClause =
    PASSWORD [IS] dataName
end

def suppressClause =
    SUPPRESS [WHEN] (zero | space | [ALL] literal)
end

def sharingClause =
    SHARING [WITH] ( READ ONLY
                   | (ALL | NO) [OTHER]
                   )
end

def paddingClause =
    PADDING [CHARACTER] [IS] (literal | identifier)
end

## #############################################################################
## I-O-CONTROL .
## -----------------------------------------------------------------------------

def ioControlParagraph =
	I-O-CONTROL .
	# TODO
	[--> (paragraphStart | sectionStart | divisionStart)]
end

## ###############################################################################
## OBJECT SECTION
## -------------------------------------------------------------------------------

def objectSection =
	( OBJECT SECTION . [objectSectionBody]
	| objectSectionBody
	)
end

def objectSectionBody =
	( classControlParagraph
	| copyStatement
    )+
end

## ###############################################################################
## CLASS-CONTROL
## -------------------------------------------------------------------------------

def classControlParagraph =
    CLASS-CONTROL .
        ( className IS CLASS literal
        | copyStatement
        )+
        [.]
end

## #############################################################################
## DATA DIVISION .
## -----------------------------------------------------------------------------

def dataDivision =
	( DATA DIVISION . [dataDivisionBody]
    | dataDivisionBody
    )
end

def dataDivisionBody =
	( fileSection
	| workingStorageSection
    | threadLocalStorageSection
    | objectStorageSection
	| localStorageSection
	| linkageSection
	| communicationSection
	| reportSection
	| screenSection
	| copyStatement
    )+
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# FILE SECTION
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def fileSection =
	FILE SECTION .
	[fileSectionBody]
end

def fileSectionBody =
	( copyStatement
	| fileDescriptionEntry (recordDescriptionEntry)*
    )+
    [--> (paragraphStart | sectionStart | divisionStart)]
end

def fileDescriptionEntry =
    ( fdFileDescriptionEntry
    | sdFileDescriptionEntry
    )
end

def fdFileDescriptionEntry =
    FD fileName
   ![ externalClause         # STD.BK sequential, relative-or-indexed, report
    | globalClause           # STD.BK sequential, relative-or-indexed, report
    | formatClause           # STD.BK sequential
    | blockContainsClause    # STD.BK sequential, relative-or-indexed, report
    | recordClause           # STD.BK sequential, relative-or-indexed, report
    | linageClause           # STD.BK sequential
    | codeSetClause          # STD.BK sequential, report
    | reportClause           # STD.BK report
    
    | dataRecords
    | labelRecords
    | recordingMode
    | threadLocalClause
    | valueOfFileId
    | valueOf
    ]
    (--> .)                  # TODO Handle skipped.
    .
end

def sdFileDescriptionEntry =
    SD fileName
   ![ recordClause           # STD.BK
    | blockContainsClause    # Supported by IBM Enterprise Cobol for z/OS.
    | dataRecords
    | labelRecords
    | recordingMode
    | valueOfFileId
    ]
    (--> .)                  # TODO Handle skipped.
    .
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# WORKING-STORAGE SECTION
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def workingStorageSection =
	WORKING-STORAGE SECTION .
    ( recordDescriptionEntry
    | replaceStatement
    | execStatement [.]
    )*
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def threadLocalStorageSection =
    THREAD-LOCAL-STORAGE SECTION .
    ( recordDescriptionEntry
    | replaceStatement
    | execStatement [.]
    )*
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def objectStorageSection =
    OBJECT-STORAGE SECTION .
    ( recordDescriptionEntry
    | replaceStatement
    | execStatement [.]
    )*
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# LOCAL-STORAGE SECTION
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def localStorageSection =
	LOCAL-STORAGE SECTION .
	( recordDescriptionEntry
    | replaceStatement
    | execStatement [.]
    )*
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# LINKAGE SECTION
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def linkageSection =
	LINKAGE SECTION .
    ( recordDescriptionEntry
    | replaceStatement
    | execStatement [.]
    )*
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# COMMUNICATION SECTION
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# * MF: http://supportline.microfocus.com/documentation/books/mx20books/atcomm.htm

def communicationSection =
	COMMUNICATION SECTION .
    ( communicationDescriptionEntry
    | recordDescriptionEntry
    )*
end

def communicationDescriptionEntry =
    ( communicationDescriptionEntry_format1
    | communicationDescriptionEntry_format2
    | communicationDescriptionEntry_format3
    )
end

def communicationDescriptionEntry_format1 =
    CD cdName [FOR] [INITIAL] INPUT
    
    ( # TODO We really want to exclude all of the possible starter tokens for
      # the other clauses.  Can we automate that somehow ?
      ( FILLER | -STATUS dataName )+
      
    | ![ [SYMBOLIC] QUEUE       [IS] dataName
       | [SYMBOLIC] SUB-QUEUE-1 [IS] dataName
       | [SYMBOLIC] SUB-QUEUE-2 [IS] dataName
       | [SYMBOLIC] SUB-QUEUE-3 [IS] dataName
       | MESSAGE DATE           [IS] dataName
       | MESSAGE TIME           [IS] dataName
       | [SYMBOLIC] SOURCE      [IS] dataName
       | TEXT LENGTH            [IS] dataName
       | END KEY                [IS] dataName
       | STATUS KEY             [IS] dataName
       | [MESSAGE] COUNT        [IS] dataName
       ]
    )
    .
end

def communicationDescriptionEntry_format2 =
    CD cdName [FOR] OUTPUT
    [ DESTINATION COUNT         [IS] dataName ]
    [ TEXT LENGTH               [IS] dataName ]
    [ STATUS KEY                [IS] dataName ]
    [ DESTINATION TABLE OCCURS integer [TIMES] [INDEXED [BY] (indexName)+] ]
    [ ERROR KEY                 [IS] dataName ]
    [ [SYMBOLIC] DESTINATION    [IS] dataName ]
    .
end

def communicationDescriptionEntry_format3 =
    CD cdName [FOR] [INITIAL] I-O
    ( (FILLER | dataName)+
    | ![ MESSAGE DATE           [IS] dataName
       | MESSAGE TIME           [IS] dataName
       | [SYMBOLIC] TERMINAL    [IS] dataName
       | TEXT LENGTH            [IS] dataName
       | END KEY                [IS] dataName
       | STATUS KEY             [IS] dataName
       ]
    )
    .
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# REPORT SECTION
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def reportSection =
	REPORT SECTION .
    ( reportDescriptionEntry (reportGroupDescriptionEntry)+ )*
end

def reportDescriptionEntry =
    RD reportName 
    ![ globalClause                    # STD.BK
     | codeClause                      # STD.BK
     | controlClause                   # STD.BK
     | pageClause                      # STD.BK
     ] .
end

def reportGroupDescriptionEntry =
    levelNumber [dataName]
    ![ lineClause                      # STD.BK
     | nextGroupClause                 # STD.BK
     | reportGroupTypeClause           # STD.BK
     | reportGroupUsageClause          # STD.BK
     | pictureClause                   # STD.BK
     | signClause                      # STD.BK
     | justifiedClause                 # STD.BK
     | blankWhenZeroClause             # STD.BK
     | columnClause                    # STD.BK
     | ( sourceClause                  # STD.BK
       | reportSectionValueClause      # STD.BK
       | sumClause                     # STD.BK
       )
     | groupIndicateClause             # STD.BK
     | occursClause                    # STD.BK
     | varyingClause                   # STD.BK
     ]
    .
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# SCREEN SECTION
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def screenSection =
	SCREEN SECTION .
    ( screenDescriptionEntry )*
    [--> (paragraphStart | sectionStart | divisionStart)]
end

def screenDescriptionEntry =
    levelNumber [FILLER | screenName]
    !( globalClause                     # STD.BK group, elementary
     | lineClause                       # STD.BK group, elementary
     | columnClause                     # STD.BK group, elementary
     | blankClause                      # STD.BK group, elementary
    
     | bellClause                       # STD.BK elementary
     | blinkClause                      # STD.BK elementary
     | highlightClause                  # STD.BK elementary
     | reverseVideoClause               # STD.BK elementary
     | underlineClause                  # STD.BK elementary
     | foregroundColorClause            # STD.BK elementary
     | backgroundColorClause            # STD.BK elementary

     | signClause                       # STD.BK group, elementary
     | fullClause                       # STD.BK group, elementary
     | autoClause                       # STD.BK group, elementary
     | secureClause                     # STD.BK group, elementary
     | requiredClause                   # STD.BK group, elementary
     | occursClause                     # STD.BK group, elementary
     | usageClause                      # STD.BK group, elementary

     | eraseClause                      # STD.BK elementary
     | pictureClause                    # STD.BK elementary
    
     | screenFromClause                 # STD.BK elementary
     | screenToClause                   # STD.BK elementary
     | screenUsingClause                # STD.BK elementary
     | screenValueClause                # STD.BK elementary
    
     | blankWhenZeroClause              # STD.BK elementary
     | justifiedClause                  # STD.BK elementary
     
     | controlClause
     | screenEntryPhrase
     )
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Other entries
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def recordDescriptionEntry =
	(constantEntry | dataDescriptionEntry | copyStatement)
end

def dataDescriptionEntry =
    ( dataDescriptionEntry_format3_and_4
    | dataDescriptionEntry_format2
    | dataDescriptionEntry_format1
    )
end

def constantEntry =
    ( constantEntry_level01
    | constantEntry_level78
    )
end

private def constantEntry_level01 =
    (1 | 01) %as levelNumber
    cobolWord %as entryName
    CONSTANT [globalClause]
    ( [AS] identifier | FROM cobolWord ) .
end

# Seen in MF and GNU COBOL
private def constantEntry_level78 =
    78 %as levelNumber
    cobolWord %as entryName 
    constantValueClause .
end


private def dataDescriptionEntry_format1 =
    levelNumber
    [(FILLER | CURSOR | dataName) %as entryName]
    
   ![ redefinesClause                  # STD.BK
    | typedefClause                    # STD.BK
    | alignedClause                    # STD.BK
    | anyLengthClause                  # STD.BK
    | basedClause                      # STD.BK
    | blankWhenZeroClause              # STD.BK
    | constantRecordClause             # STD.BK
    | externalClause                   # STD.BK
    | globalClause                     # STD.BK
    | groupUsageClause                 # STD.BK
    | justifiedClause                  # STD.BK
    | occursClause                     # STD.BK
    | pictureClause                    # STD.BK
    | propertyClause                   # STD.BK
    | sameAsClause                     # STD.BK
    | selectWhenClause                 # STD.BK
    | signClause                       # STD.BK
    | synchronizedClause               # STD.BK
    | typeNameTypeClause               # STD.BK
    | classClause                      # STD.BK
    | defaultClause                    # STD.BK
    | destinationClause                # STD.BK
    | (invalidClause)+                 # STD.BK
    | presentWhenClause                # STD.BK
    | varyingClause                    # STD.BK
    | validateStatusClause             # STD.BK
    | valueClause                      # STD.BK
    
    | threadLocalClause
    | dtLinePos
    | columnClause
    | autoClause
    | backgroundColorClause
    | bellClause
    | blinkClause
    | controlPhrase
    | eraseClause
    | fillPhrase
    | foregroundColorClause
    | fullClause
    | gridPhrase
    | highPhrase
    | lowPhrase
    | linePhrase
    | promptPhrase
    | requiredPhrase
    | reversePhrase
    | securePhrase
    | sizePhrase
    | USING identifier
    | FROM (identifier | literal) [TO identifier]
    | PUBLIC
    | PRIVATE
    | PROTECTED
    | INTERNAL
    | attributeClause
    
    | usageClause      # STD.BK -- Note: This has some catch-alls in it.
    | literal
    ]
    (--> .)  # TODO Handle skipped.
    .
end

private def dataDescriptionEntry_format2 =
    66 %as levelNumber
    dataName %as entryName
    renamesClause
    . 
end

private def dataDescriptionEntry_format3_and_4 =
    88 %as levelNumber
    [-(VALUE|VALUES) conditionName %as entryName]
    valueClause
    .
end


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def dataRecords =
    [DATA] ( RECORD [IS] | RECORDS [ARE] ) (dataName)+
end

def labelRecords =
    LABEL ( RECORD [IS] | RECORDS [ARE] ) (OMITTED | STANDARD | (dataName)+)
end

def recordingMode =
    RECORDING [MODE] [IS] ( F | V | U | S | FIXED | VARIABLE )
end

def valueOfFileId =
    VALUE OF FILE-ID [IS] (dataName | literal)
end

def valueOf =
    VALUE OF (
      (IDENTIFICATION | ID | cobolWord) [IS] (dataName | literal)
    )+
end

# Cfr. a.o. http://ibmmainframes.com/post-55387.html
def cicsValue =
	(DFHVALUE | DFHRESP) '(' cobolWord ')'
end

# See https://sourceforge.net/p/open-cobol/manual/, page 5-15.
def whenSetToFalseClause =
    [WHEN] [SET] [TO] FALSE [IS] literal
end

def blankWhenZero =
    BLANK [WHEN] zero
end

def threadLocalClause =
    [IS] THREAD-LOCAL
end

def zero =
    (ZERO | ZEROS | ZEROES)
end

def space =
    (SPACE | SPACES)
end

def justified =
    [OUTPUT] (JUSTIFIED | JUST) [LEFT | RIGHT | CENTERED]
end

# TODO The recurring negations in here (-FALSE) are pretty ugly...
def valueClause =
    ( VALUE [IS] | VALUES [ARE] )
    
    (
      # table
      ( (literal)+
        FROM '(' (subscript)+ ')'
        [ TO '(' (subscript)+ ')' ] 
      )+
      
    | ( ( cicsValue
    
        | # data-item, condition-name, report-section, content-validation-entry
          (-FALSE) literal
        )
        
        # condition-name, content-validation-entry
        [(THROUGH | THRU) literal]
      )+

      # condition-name, content-validation-entry
      [[IN] (-FALSE) alphabetName]
    
      # condition-name
      [[WHEN] [SET] [TO] FALSE [IS] literal]

      # content-validation-entry
      [[IS | ARE] (INVALID | VALID)] [WHEN condition]
        
    | constant
    )
end


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DATA DIVISION clauses
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def alignedClause =
    ALIGNED
end

def anyLengthClause =
    ANY LENGTH
end

def autoClause =
    ( # screen
      AUTO
    | AUTO-SKIP
    )
end

def backgroundColorClause =
    (BACKGROUND-COLOR | BACKGROUND-COLOUR) [IS] integer
end

def basedClause =
    BASED
end

def bellClause =
    BELL
end

def blankClause =
    BLANK (SCREEN | LINE)
end

def blankWhenZeroClause =
    BLANK [WHEN] zero
end

def blinkClause =
    BLINK
end

def blockContainsClause =
    BLOCK [CONTAINS] integer [TO integer] [CHARACTERS | RECORDS]
end

def classClause =
    CLASS [IS]
    ( NUMERIC
    | ALPHABETIC
    | ALPHABETIC-LOWER
    | ALPHABETIC-UPPER
    | BOOLEAN
    | name                     #= alphabetName or className
    )
end

def codeClause =
    [WITH] CODE (literal | identifier)
end

def codeSetClause =
    CODE-SET [IS] alphabetName [FOR (identifier)+]
end

def columnClause =
    # report-writer, screen-item
	( (COL | COLUMN) [NUMBER | NUMBERS]
	| COLUMNS
	| COLS
	)
	
	# report-writer
	[LEFT | CENTER | RIGHT]
	
	[IS | ARE]
	
	[PLUS | '+' | MINUS | '-'] (integer | identifier | literal)
end

def constantRecordClause =
    CONSTANT RECORD
end

# MF: see http://supportline.microfocus.com/Documentation/books/sx50/lhpdf402.htm
def constantValueClause =
    VALUE [IS]
    
    ( NEXT                       # MF
    | START  [OF] dataName       # MF
    | LENGTH [OF] dataName       # MF
    | literal                    # MF and GNU COBOL
    )
    
    [ # MF
      (AND | OR | '&' | '+' | '-' | '*' | '/')
      ( NEXT
      | START  [OF] dataName
      | LENGTH [OF] dataName
      | integer
      )
    ]
end

def controlClause =
    (CONTROL [IS] | CONTROLS [ARE]) (FINAL (dataName)* | (dataName)+)
end

def defaultClause =
    DEFAULT [IS] (NONE | literal | identifier)
end

def destinationClause =
    DESTINATION [IS] (identifier)+
end

def eraseClause =
    ERASE 
    [ EOL 
    | EOS
    | [END OF] LINE
    | [END OF] SCREEN
    ]
end

def externalClause =
    # TODO BY ?
    [IS] EXTERNAL [(AS | BY) literal]
end

def foregroundColorClause =
    (FOREGROUND-COLOR | FOREGROUND-COLOUR) [IS] (integer | identifier)
end

def formatClause =
    FORMAT !(BIT | CHARACTER | NUMERIC) DATA
end

def fullClause =
    FULL
end

def globalClause =
    [IS] GLOBAL
end

def groupIndicateClause =
    GROUP [INDICATE]
end

def groupUsageClause =
    GROUP-USAGE [IS] (BIT | NATIONAL)
end

def highlightClause =
    (HIGHLIGHT | LOWLIGHT)
end

def invalidClause =
    INVALID WHEN condition
end

def justifiedClause =
    (JUSTIFIED | JUST) [RIGHT]
end


def linageClause =
    LINAGE [IS] (dataName | integer) [LINES]
    [footingClause]
    [linesAtTopClause]
    [linesAtBottomClause]
end

def footingClause       = [WITH] FOOTING [AT] (dataName | integer)  end
def linesAtTopClause    = [LINES] [AT] TOP (dataName | integer)     end
def linesAtBottomClause = [LINES] [AT] BOTTOM (dataName | integer)  end


def lineClause =
    ( # report-writer, screen 
      LINE [NUMBER | NUMBERS] [IS | ARE]
      
    | # report-writer
      LINES [ARE]
    )
    
    ( ( # report-writer
        integer [[ON] NEXT PAGE]
      
      | # report-writer, screen
        (PLUS | '+') (integer | identifier)
      
      | # report-writer
        [ON] NEXT PAGE
      )+
    
    | # screen
      (PLUS | '+' | MINUS | '-') (integer | identifier)
    )      
    
end

def nextGroupClause =
    NEXT GROUP [IS]
    ( integer
    | PLUS integer
    | NEXT PAGE [[WITH] RESET]
    )
end

def occursClause =
    OCCURS
    ( ( # dynamic-capacity-table
        DYNAMIC
        [CAPACITY [IN] dataName]
        [FROM integer]
        [TO integer]
        [INITIALIZED]
        
      | # fixed-table, occurs-depending-table, report-writer
        [integer TO] integer [TIMES]
      )
    
        # occurs-depending-table, report-writer
        [ DEPENDING [ON] qualifiedDataName ]
        
        # report-writer
        [ STEP integer ]
        
        # fixed-table, occurs-depending-table, dynamic-capacity-table
        ( (ASCENDING | DESCENDING) [KEY] [IS] (qualifiedDataName)+ )*
        ( INDEXED [BY] (indexName)+ )*
        
    | ANY
    )
end

def pageClause =
    PAGE [LIMIT | LIMITS] [IS | ARE] integer [LINE | LINES]
    [ HEADING integer ]
    [ FIRST DETAIL integer ]
    [ LAST DETAIL integer ]
    [ FOOTING integer ]
end


def pictureClause =
    (PIC | PICTURE) [IS] pictureString
    [pictureLocaleClause]
end

def pictureLocaleClause =
  LOCALE [[IS] cobolWord]
  SIZE [IS] integer
end


def presentWhenClause =
    PRESENT WHEN condition
end

def propertyClause =
    PROPERTY [ [WITH] NO (GET | SET) ] [[IS] FINAL]
end

def recordClause =
    RECORD ( recordContainsClause | recordIsVaryingClause )
end

def recordContainsClause = [CONTAINS] integer [TO integer] [CHARACTERS] end
def recordIsVaryingClause =
    [IS] VARYING [IN] [SIZE]
    [[FROM] integer [TO integer] [CHARACTERS]]
    [DEPENDING [ON] fileName]
end


def redefinesClause =
    REDEFINES dataName
end

def renamesClause =
    RENAMES qualifiedDataName
    [(THROUGH | THRU) qualifiedDataName]
end

def reportClause =
    ( REPORT [IS] | REPORTS [ARE] ) (reportName)+
end

def reportGroupTypeClause =
    TYPE [IS]
    ( (RH | REPORT HEADING )
    | (PH | PAGE HEADING   )
    | (CH | CONTROL HEADING) [ON|FOR] (FINAL | dataName)
    | (DE | DETAIL         )
    | (CF | CONTROL FOOTING) [ON|FOR] (FINAL | dataName)
    | (PF | PAGE FOOTING   )
    | (RF | REPORT FOOTING )
    )
end

def reportGroupUsageClause =
    USAGE [IS] (DISPLAY | DISPLAY-1) 
end

def reportSectionValueClause =
    (VALUE [IS] | VALUES [ARE]) (literal)+
end

def reverseVideoClause =
    REVERSE-VIDEO
end

def requiredClause =
    REQUIRED
end

def sameAsClause =
    SAME AS dataName
end

def screenFromClause =
    FROM (literal | identifier)
end

def screenToClause =
    TO identifier
end

def screenUsingClause =
    USING identifier
end

def screenValueClause =
    VALUE [IS] literal
end


def secureClause =
    SECURE
end

def selectWhenClause =
    SELECT WHEN (OTHER | conditionName)
end

def signClause =
    [SIGN [IS]] (LEADING | TRAILING) [SEPARATE [CHARACTER]]
end

def sourceClause =
    (SOURCE [IS] | SOURCES [ARE])
    (arithmeticExpression | identifier)+
    [roundedPhrase]
end

def sumClause =
    (SUM [OF] (-UPON identifier)+ [UPON (dataName)+])+
    [RESET [ON] (FINAL | dataName)]
    # TODO [roundedPhrase]
end

def synchronizedClause =
    (SYNCHRONIZED | SYNC) [LEFT | RIGHT]
end

def typedefClause =
    [IS] TYPEDEF [STRONG]
end

def typeNameTypeClause =
    TYPE [TO] typeName
end

def underlineClause =
    UNDERLINE
end

def usageClause =
    [USAGE [IS]] usageOperand
end

def usageOperand =
    ( BINARY                                # *ANSI85
    | BINARY-C-LONG
    | BINARY-CHAR   [SIGNED | UNSIGNED]     # *ISO2002 *MF
    | BINARY-DOUBLE [SIGNED | UNSIGNED]     # *ISO2002 *MF
    | BINARY-LONG   [SIGNED | UNSIGNED]     # *ISO2002 *MF
    | BINARY-SHORT  [SIGNED | UNSIGNED]     # *ISO2002 *MF
    | BIT
    | CHARACTER                             # *.NET *JVM
    | COMPUTATIONAL
    | COMP
    | COMPUTATIONAL-1                       # *OSVS *VSC2 *MF
    | COMP-1                                # *OSVS *VSC2 *MF
    | COMPUTATIONAL-2                       # *OSVS *VSC2 *MF
    | COMP-2                                # *OSVS *VSC2 *MF
    | COMPUTATIONAL-3                       # *OSVS *VSC2 *MF *XOPEN
    | COMP-3                                # *OSVS *VSC2 *MF *XOPEN
    | COMPUTATIONAL-4                       # *OSVS *VSC2 *MF
    | COMP-4                                # *OSVS *VSC2 *MF
    | COMPUTATIONAL-5                       # *OSVS *VSC2 *MF
    | COMP-5                                # *OSVS *VSC2 *MF
    | COMPUTATIONAL-6                       # *ACUCOBOL-GT
    | COMP-6                                # *ACUCOBOL-GT
    | COMPUTATIONAL-X                       # *MF
    | COMP-X                                # *MF
    | COMPUTATIONAL-N                       # *ACUCOBOL-GT
    | COMP-N                                # *ACUCOBOL-GT
    | CONDITION-VALUE                       # *.NET *JVM
    | DECIMAL                               # *.NET *JVM
    | DISPLAY
    | DISPLAY-1
    | DOUBLE                                # *ACUCOBOL-GT
    | INDEX
    | FLOAT                                 # *ACUCOBOL-GT
    | FLOAT-EXTENDED
    | FLOAT-LONG
    | FLOAT-SHORT
    | HANDLE [[OF]                          # *ACUCOBOL-GT
        ( WINDOW
        | SUBWINDOW
        | FONT [cobolWord]
        | THREAD
        | MENU
        | VARIANT
        | LAYOUT-MANAGER [cobolWord]
        ) 
      ]
    | MONITOR-POINTER                       # *MF
    | MUTEX-POINTER                         # *MF
    | NATIONAL                              # *ISO2002 *MF
    | OBJECT REFERENCE                      # *.NET *ISO2002 *MF
        [ [FACTORY OF] ACTIVE-CLASS
        | [FACTORY OF] className [ONLY | EVENT]
        ]
    | OBJECT                                # *.NET *JVM
    | PACKED-DECIMAL                        # *ANSI85
    | POINTER                               # *VSC2 *MF
    | PROCEDURE-POINTER                     # *COB370 *MF
    | PROGRAM-POINTER [[TO] programName]    # *ISO2002 *MF
    | SEMAPHORE-POINTER                     # *MF
    | SIGNED-INT
    | SIGNED-LONG
    | SIGNED-SHORT
    | THREAD-POINTER                        # *MF
    | UNSIGNED-INT
    | UNSIGNED-LONG
    | UNSIGNED-SHORT
    | STRING                                # *.NET *JVM
    | typedefName                           # *MF
    | className                             # *.NET *JVM
    )
end


def validateStatusClause =
    (VALIDATE-STATUS | VAL-STATUS) [IS] (literal | identifier)
    [WHEN] [NO] ERROR
    [ON !(FORMAT | CONTENT | RELATION)]
    FOR (identifier)+
end

def varyingClause =
    VARYING (dataName [FROM arithmeticExpression] [BY arithmeticExpression])+
end




## #############################################################################
## PROCEDURE DIVISION .
## -----------------------------------------------------------------------------

# I have seen descriptions of the format for procedure divisions where if you
# use sections everything must be inside a section. That is, there can be no
# leading statements or paragraphs. This however conflicts with actual code I
# have seen. I therefore do not enforce this rule and accept leading statements
# and paragraphs.

def procedureDivision =
	procedureDivisionHeader
	[declaratives]
    (sentence)*
    (paragraph)*
    (section)*
#	[--> divisionStart]
end

def procedureDivisionHeader =
	PROCEDURE DIVISION [mnemonicName] [usingOrChainingPhrase] [returningProcedurePhrase] .
end


# Refs. http://supportline.microfocus.com/documentation/books/nx60/lhpdf602.htm
def usingOrChainingPhrase =
    (USING | CHAINING | GIVING) 
    (dataReference | dataValue | dataOutput)+
    [repeatedPhrase]
end

def dataReference = 
	[[BY] REFERENCE]
    ( ANY | [OPTIONAL] dataName [DELIMITED [BY SIZE]] [AS typeName [attributeClause]] | typedefName )+
end

def dataValue =
	[BY] VALUE ( ANY | dataName [AS typeName [attributeClause]] | typedefName )+
end

def dataOutput =
    [BY] OUTPUT ( dataName AS typeName [attributeClause] )*
end

def repeatedPhrase =
    REPEATED [integer TO integer]
end

def returningProcedurePhrase =
	(RETURNING | YIELDING | GIVING)
    dataName [AS typeName [attributeClause]]
end


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Common phrases and features
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def roundedPhrase =
    ROUNDED
    [ MODE [IS]
      ( AWAY-FROM-ZERO
      | NEAREST-AWAY-FROM-ZERO
      | NEAREST-EVEN
      | NEAREST-TOWARD-ZERO
      | PROHIBITED
      | TOWARD-GREATER
      | TOWARD-LESSER
      | TRUNCATION
      )
    ]
end

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def declaratives =
    DECLARATIVES .
    (declarativeSection)*
    END DECLARATIVES .
end

def declarativeSection =
    sectionName SECTION .
    ((useStatement .) %as statement) %as sentence
    (sentence)*
    (paragraph)*
end

def section =
    sectionName SECTION [segmentNumber] .
    (sentence)*
    (paragraph)*
end

def paragraph =
    paragraphName .
    (sentence)*
end

#Modified by Adrian Noguero
def sentence =
    ( compilerStatement
    | statement (compilerStatement | statement | continuationOfStatement)* .
    | .
    )
end

def statement =
    (
     $( ACCEPT     => acceptStatement
      | ADD        => addStatement
      | ALTER      => alterStatement
      | CALL       => callStatement
      | CHAIN      => chainStatement        # *MF
      | CANCEL     => cancelStatement
      | CLOSE      => closeStatement
      | COMMIT     => commitStatement       # *MF
      | COMPUTE    => computeStatement
      | CONTINUE   => continueStatement
      | DELETE     =>
    	  ( deleteFileStatement   # *MF
    	  | deleteStatement )
      | DISABLE    => disableStatement
      | DISPLAY    => displayStatement
      | DIVIDE     => divideStatement
      | ENABLE     => enableStatement
      | ENTRY      => entryStatement
      | EVALUATE   => evaluateStatement
      | EXAMINE    => examineStatement      # *MF
      | EXEC       => execStatement
      | EXHIBIT    => exhibitStatement      # *MF
      | EXIT       => exitStatement
      | GENERATE   => generateStatement
      | GOBACK     => gobackStatement
      | GO         => goToStatement
      | IDENTIFIED => identifiedByStatement # *MF
      | IF         => ifStatement
      | INITIATE   => initiateStatement
      | INVOKE     => invokeStatement       # *ISO2002 *MF
      | MERGE      => mergeStatement
      | MOVE       => moveStatement
      | MULTIPLY   => multiplyStatement
      | NEXT       => nextSentenceStatement # *MF
      | ON         => onStatement           # *OSVS
      | OPEN       => openStatement
      | PERFORM    => performStatement
      | RAISE      => raiseStatement        # *.NET
      | READ       => readStatement
      | READY      => readyTraceStatement   # *OSVS *VSC2
      | RECEIVE    => receiveStatement
      | RELEASE    => releaseStatement
      | RESET      => resetTraceStatement   # *OSVS *VSC2
      | RETURN     => returnStatement
      | REWRITE    => rewriteStatement
      | ROLLBACK   => rollbackStatement     # *MF
      | PURGE      => purgeStatement
      | SEARCH     => searchStatement
      | SEND       => sendStatement
      | SERVICE    => serviceStatement      # *OSVS *VSC2
      | SORT       => sortStatement
      | START      => startStatement
      | STOP       => stopStatement
      | STRING     => stringStatement
      | SUBTRACT   => subtractStatement
      | SUPPRESS   => suppressStatement
      | TERMINATE  => terminateStatement
      | TRANSFORM  => transformStatement    # *MF
      | UNLOCK     => unlockStatement       # *MF
      | UNSTRING   => unstringStatement
      | WAIT       => waitStatement         # *MF
      | WRITE      => writeStatement
      | XML        => 
          ( xmlGenerateStatement  # *MF
          | xmlParseStatement )   # *MF
      | SET        => setStatement
      | INITIALIZE => initializeStatement
      | INSPECT    => inspectStatement
    
      | ALLOCATE   => allocateStatement
      | FREE       => freeStatement
      )
    
    | verb
      [--> ( . | endOfStatement | verb | subStatementMarker)]
    )
end

def subStatementMarker =
	( ELSE 
	| WHEN
	| NOT INVALID
	| INVALID
	| NOT [ON] SIZE
	| [ON] SIZE
	| NOT [ON] OVERFLOW
	| [ON] OVERFLOW
	| NOT [ON] EXCEPTION
	| [ON] EXCEPTION
	| NOT [AT] END
	| [AT] END
	| NOT [AT] END-OF-PAGE
	| NOT [AT] EOP
	| [AT] END-OF-PAGE
	| [AT] EOP )
end

def continuationOfStatement (Token t) =
    ( t=eventPhrase 
      { warn(t, "Nested statement found out of line."); }
      statement

    | t=endOfStatementMarker
      { warn(t, "Loose end of statement."); }
    )
end

def nestedStatements =
    (statement)+
end

def eventPhrase (Token t) returns t =
    [NOT] [ON | AT]
    ( t=EXCEPTION
    | t=SIZE ERROR
    | t=OVERFLOW
    | t=INVALID [KEY]
    | t=END
    | t=END-OF-PAGE
    | t=EOP
    )
end

def retryPhrase =
    RETRY 
    ( (identifier | integer) TIMES
    | FOR (identifier | integer) SECONDS
    | FOREVER
    )
end

def endOfStatementMarker (Token t) returns t =
    ( t=END-ACCEPT
    | t=END-ADD
    | t=END-CALL
    | t=END-CHAIN       # *MF
    | t=END-COMPUTE
    | t=END-DELETE
    | t=END-DIVIDE
    | t=END-EVALUATE
    | t=END-EXEC
    | t=END-IF
    | t=END-MULTIPLY
    | t=END-PERFORM
    | t=END-READ
    | t=END-RETURN
    | t=END-REWRITE
    | t=END-SEARCH
    | t=END-START
    | t=END-STRING
    | t=END-SUBTRACT
    | t=END-UNSTRING
    | t=END-WAIT        # *MF
    | t=END-WRITE
    )
end

def verb =
    ( ADD
    | ALTER
    | CALL
    | CANCEL
    | CHAIN         # *MF
    | CLOSE
    | COMMIT        # *MF
    | CONTINUE
    | DELETE
    | DIVIDE
    | EJECT
    | ENTRY
    | EVALUATE
    | EXEC
    | EXIT
    | GENERATE
    | GOBACK
    | GO
    | IDENTIFIED    # *MF
    | IF
    | INITIATE
    | INVOKE        # *MF
    | MERGE
    | MOVE
    | MULTIPLY
    | NEXT SENTENCE # *MF
    | OPEN
    | PERFORM
    | RAISE         # *.NET
    | READ
    | READY TRACE
    | RELEASE
    | REPLACE
    | RESET TRACE
    | RETURN
    | REWRITE
    | ROLLBACK      # *MF
    | SEARCH
    | SERVICE
    | SKIP1
    | SKIP2
    | SKIP3
    | SORT
    | STOP
    | STRING
    | SUBTRACT
    | SUPPRESS
    | TERMINATE
    | TITLE
    | UNSTRING
    | WAIT
    | WRITE
    | XML GENERATE  # *MF
    | XML PARSE     # *MF
    | SET
    | INITIALIZE
    | DISPLAY
    | COMPUTE
    | INSPECT
    | ACCEPT
    
    | ALLOCATE
    | FREE

    | XML           # See xmlGenerateStatement

    # Communication verbs:
    | ENABLE
    | DISABLE
    | SEND
    | RECEIVE
    | PURGE
    
    # Verbs for statements implemented by Adrian
    | START
    | USE
    )
end


## #############################################################################
## ACCEPT statement.
## -----------------------------------------------------------------------------

def acceptStatement =
    ACCEPT 
    ( acceptFromDate
    | acceptScreenSizeData             # GNUCobol
    | acceptFromOther
    | acceptFromMnemonic
    | acceptMessageCount
    | acceptScreenFormat
    
    # Catch all.
    # | (--> endOfStatement)
    )
        
    [END-ACCEPT]
end

def acceptFromMnemonic =
    identifier_format2
    FROM mnemonicName
    
    [ onException | onEscape ]
    [ notOnException | notOnEscape ]
end

def acceptFromOther =
    identifier_format2
    FROM
    ( TERMINAL-INFO
    | SYSTEM-INFO
    | INPUT STATUS
    | ESCAPE KEY
    | EXCEPTION STATUS
    | LINE NUMBER
    | USER NAME
    | COMMAND-LINE
    | STANDARD OBJECT identifier
    | THREAD HANDLE
    | WINDOW HANDLE
    | ENVIRONMENT ( name | alphanumericLiteral )
    )
end

def acceptScreenFormat =
    ( OMITTED | identifier )
    [ unitPhrase ]
    [ dtLineColPositioning | dtAtPositioning ]
    [ FROM CRT ]
    [ modeIsBlockPhrase ]
    [ WITH (screenEntryPhrase)+ ]
    [ onException | onEscape ]
    [ notOnException | notOnEscape ]
end

def acceptFromDate =
    identifier_format2
    FROM
    ( DATE [YYYYMMDD | CENTURY-DATE]
    | DAY  [YYYYDDD | CENTURY-DAY]
    | DAY-OF-WEEK
    | TIME
    | YEAR
    | YYYYMMDD
    | CENTURY-DATE
    | YYYYDDD 
    | CENTURY-DAY
    )
end

def acceptMessageCount =
    identifier [MESSAGE] COUNT
end

def unitPhrase =
    UNIT (identifier | literal)
end

def modeIsBlockPhrase =
    MODE [IS] BLOCK
end

def acceptScreenSizeData =
    identifier FROM (LINES | COLUMNS)
end


## #############################################################################
## ADD statement.
## -----------------------------------------------------------------------------

def addStatement =
    ADD ( addition_format1 | addition_format2 | addition_format3 )
    [onSizeError]
    [notOnSizeError]
    [END-ADD]
end

def addition_format1 =
    (CORRESPONDING | CORR) qualifiedDataName TO qualifiedDataName [ROUNDED]
end

def addition_format2 =
    (identifier | literal)+
    [TO (identifier | literal)]
    GIVING (qualifiedDataName [ROUNDED])+
end

def addition_format3 =
    (identifier | literal)+
    TO (identifier [ROUNDED])+
end


## #############################################################################
## ALLOCATE statement.
## -----------------------------------------------------------------------------

# See https://sourceforge.net/p/open-cobol/manual/, page 6-33.

def allocateStatement =
    ALLOCATE
    ( arithmeticExpression CHARACTERS
    | qualifiedDataName
    )
    [ INITIALIZED ]
    [ RETURNING qualifiedDataName ]
end

## #############################################################################
## ACCEPT statement.
## -----------------------------------------------------------------------------

def alterStatement =
    ALTER (alterationClause)+
end

def alterationClause =
    procedureName TO [PROCEED TO] procedureName
end

## #############################################################################
## CALL statement.
## -----------------------------------------------------------------------------

def callStatement =
    CALL
    
    ( NESTED
    | mnemonicName (alphanumericLiteral | identifier)
    | (alphanumericLiteral | identifier) [AS (NESTED | programName)]
    )
    
    [ callUsing ]
    [ callGivingOrReturning ]

    [ # Call statement format 1.
      onOverflow
    
    | # Call statement format 2.
      onException
      [notOnException]

    | # Call statement format 2.
      notOnException
    ]

    [END-CALL]
end

def callUsing =
    USING ( [[BY] REFERENCE] ( ADDRESS OF identifier
                             | OMITTED
                             | identifier
                             | literal
                             )
          | [BY] CONTENT     ( LENGTH OF identifier
                             | arithmeticExpression
                             | identifier
                             | literal
                             )
          | [BY] VALUE       ( LENGTH OF identifier [ SIZE [IS] [LENGTH OF identifier | integer] ]
                             | integer SIZE [IS] [LENGTH OF identifier | integer]
                             | arithmeticExpression
                             | identifier
                             | literal
                             )
          )+
end

def callGivingOrReturning =
    (GIVING | RETURNING) [INTO | ADDRESS OF] identifier
end

def onOverflow =
    [ON] OVERFLOW nestedStatements
end

def notOnOverflow =
    NOT [ON] OVERFLOW nestedStatements
end

def onException =
    [ON] EXCEPTION nestedStatements
end

def notOnException =
    NOT [ON] EXCEPTION nestedStatements
end

def onSizeError =
    [ON] SIZE ERROR nestedStatements
end

def notOnSizeError =
    NOT [ON] SIZE ERROR nestedStatements
end

def onEscape =
    [ON] ESCAPE nestedStatements
end

def notOnEscape =
    NOT [ON] ESCAPE nestedStatements
end

def programID =
    (identifier | alphanumeric)
end

## #############################################################################
## CANCEL statement.
## -----------------------------------------------------------------------------

def cancelStatement =
    CANCEL (identifier | alphanumeric)+
end

## #############################################################################
## CHAIN statement.
## -----------------------------------------------------------------------------

def chainStatement =
    CHAIN (identifier | literal)
    [ chainUsing ]
    [END-CHAIN]
end

def chainUsing =
    USING (literal | identifier)*
          ( [BY] REFERENCE ([ADDRESS OF] identifier | OMITTED | literal)+
          | [BY] CONTENT (literal | identifier)+
          | [BY] VALUE ([LENGTH OF] identifier | integer [SIZE [IS] integer] | literal)+
          )*
end

## #############################################################################
## CLOSE statement.
## -----------------------------------------------------------------------------

def closeStatement =
    CLOSE (fileName
      [ [WITH] (NO REWIND | LOCK)
      | (REEL | UNIT) [[FOR] REMOVAL]
      | [FOR] REMOVAL
      ]
    )+
end

## #############################################################################
## COMMIT statement.
## -----------------------------------------------------------------------------

# Seen in PERCobol Language Reference Manual.
def commitStatement =
    COMMIT [TRANSACTION]
end

# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDF808.html

## #############################################################################
## COMPUTE statement.
## -----------------------------------------------------------------------------

def computeStatement =
    COMPUTE
    (qualifiedDataName [ROUNDED])+
    ('=' | EQUAL)
    arithmeticExpression
    [onSizeError]
    [notOnSizeError]
    [END-COMPUTE]
end

## #############################################################################
## CONTINUE statement.
## -----------------------------------------------------------------------------

def continueStatement =
    CONTINUE
end


## #############################################################################
## DELETE statement.
## -----------------------------------------------------------------------------

def deleteStatement =
    DELETE fileName [RECORD]
    
    [invalidKey]
    [notInvalidKey]
    
    [END-DELETE]
end

def invalidKey =
    INVALID [KEY] nestedStatements
end

def notInvalidKey =
    NOT INVALID [KEY] nestedStatements
end


## #############################################################################
## DELETE FILE statement.
## -----------------------------------------------------------------------------

def deleteFileStatement =
    DELETE FILE (fileName)+
end

# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDF80C.html

## #############################################################################
## DISABLE statement.
## -----------------------------------------------------------------------------

def disableStatement =
    DISABLE (INPUT [TERMINAL] | I-O TERMINAL | OUTPUT)
            cdName [WITH] KEY (literal | identifier)
end

## #############################################################################
## DISPLAY statement.
## -----------------------------------------------------------------------------

def displayStatement =
    DISPLAY
    ( OMITTED | identifier | literal )+
	
	( uponClause
	| withNoAdvancing
    | UNIT (identifier | literal)
    | dtAtPositioning
    | dtLineColPositioning
    | uponClause
    | modeIsBlockPhrase
    | [WITH] (screenEntryPhrase)+
    )*
	
    [onException]
    [notOnException]
    
	[END-DISPLAY]
end

def displayStatement__ =
	DISPLAY 
	( displayTerminalFormat
	| displayDeviceFormat
##   | --> (. | endOfStatement)
	)
	[END-DISPLAY]
end

def displayDeviceFormat =
	(identifier | literal)+
	[uponClause]
	[withNoAdvancing]
    [onException]
    [notOnException]
end

def uponClause =
	UPON
	( ARGUMENT-NUMBER
    | COMMAND-LINE
    | ENVIRONMENT-VALUE
    | ENVIRONMENT-NAME
	| environmentName
	| mnemonicName
	)
end

def withNoAdvancing =
	[WITH] NO ADVANCING
end

def displayTerminalFormat =
    (
        ( OMITTED | identifier | literal )
        [ UNIT (identifier | literal) ]
        ( dtAtPositioning | dtLineColPositioning )
        [ uponClause ]
        [ modeIsBlockPhrase ]
        [ [WITH] (screenEntryPhrase)+ ]
    )+
end

def dtAtPositioning =
	AT (identifier | literal)
end

def dtLineColPositioning =
	[AT | FROM] ( dtLinePos [dtColPos]
	            | dtColPos [dtLinePos]
	            )
end

def dtLinePos =
	LINE [NUMBER] [IS] [PLUS | '+' | '-'] (identifier | literal)
end

def dtColPos =
	(COL | COLUMN | POSITION | POS) [NUMBER] [IS] [PLUS | '+' | '-'] (identifier | literal)
end

# TODO: Split screenEntryPhrase into:
#       * screenEntryOption_Accept
#       * screenEntryOption_Display
#       * screenEntryOption_InputField (maybe)
#       * screenEntryOption_OutputField ( maybe)
#       * screenEntryOption_UpdateField (maybe)
#       * screenEntryOption_LiteralField (maybe)

def screenEntryPhrase =
    ( autoPhrase
    | beepPhrase
    | blankPhrase
    | blankWhenZero
    | blinkPhrase
    | boldPhrase
    | capitalizationPhrase
    | controlPhrase
    | convertPhrase
    | cursorPhrase
    | echoPhrase
    | erasePhrase
    | fillPhrase
    | fullPhrase
    | gridPhrase
    | justificationPhrase
    | justified
    | highPhrase
    | lowPhrase
    | linePhrase
    | offPhrase
    | pictureClause
    | promptPhrase
    | requiredPhrase
    | reversePhrase
    | scrollPhrase
    | securePhrase
    | sizePhrase
    | standardPhrase
    | foregroundPhrase
    | backgroundPhrase
    | timeoutPhrase
    | trailingSignPhrase
    | tabPhrase
    | timePhrase
    | updatePhrase
    )
end

def autoPhrase =
    (AUTO | AUTO-SKIP)
end

def backgroundPhrase =
    (BACKGROUND-COLOR | BACKGROUND-COLOUR) [IS] integer
end

def beepPhrase =
    [NO] (BEEP | BELL)
end

def blankPhrase =
    BLANK (SCREEN | LINE)
end

def blinkPhrase =
    (BLINKING | BLINK)
end

def boldPhrase =
    BOLD
end

def capitalizationPhrase =
    (UPPER | LOWER)
end

def controlPhrase =
    CONTROL [IS] (identifier_format2 | literal)
end

def convertPhrase =
    (CONVERT | CONVERSION)
end

def cursorPhrase =
    CURSOR (identifier | literal)
end

def echoPhrase =
    ECHO
end

def erasePhrase =
    ERASE [EOL | EOS]
end

def foregroundPhrase =
    (FOREGROUND-COLOR | FOREGROUND-COLOUR) [IS] integer
end

def fullPhrase =
    (FULL | LENGTH-CHECK)
end

def gridPhrase =
    GRID
end

def highPhrase =
    (HIGH | HIGHLIGHT)
end

def linePhrase =
    (LEFTLINE | OVERLINE | UNDERLINE)
end

def lowPhrase =
    (LOW | LOWLIGHT)
end

def offPhrase =
    OFF
end

def promptPhrase =
    PROMPT
    [ CHARACTER [IS] identifier
    | [CHARACTER] [IS] literal
    ]
end

def requiredPhrase =
    (REQUIRED | EMPTY-CHECK)
end

def reversePhrase =
    (REVERSE | REVERSED | REVERSE-VIDEO)
end

def scrollPhrase =
    SCROLL (UP | DOWN)
    [[BY] (integer | identifier) (LINE | LINES)]
end

def securePhrase =
    (SECURE | NO-ECHO)
end

def sizePhrase =
    SIZE [IS] (identifier | literal)
end

def standardPhrase =
    STANDARD
end

def tabPhrase =
    TAB
end

def timePhrase =
    [BEFORE] TIME (identifier | literal)
end

def timeoutPhrase =
    (TIME-OUT | TIMEOUT) AFTER (identifier | integer)
end

def justificationPhrase =
    (LEFT-JUSTIFY | RIGHT-JUSTIFY)
end

def fillPhrase =
    (SPACE-FILL | ZERO-FILL)
end

def trailingSignPhrase =
    TRAILING-SIGN
end

def updatePhrase =
    UPDATE
end

## #############################################################################
## DIVIDE statement.
## -----------------------------------------------------------------------------

def divideStatement =
    DIVIDE ( division_format1 | division_format2 | division_format3 )
    [onSizeError]
    [notOnSizeError]
    [END-DIVIDE]
end

def division_format1 =
    (identifier | literal)
    (INTO | BY) (identifier | literal)
    GIVING qualifiedDataName [ROUNDED]
    REMAINDER qualifiedDataName
end

def division_format2 =
    (identifier | literal)
    (INTO | BY) (identifier | literal)
    GIVING (qualifiedDataName [ROUNDED])+
end

def division_format3 =
    (identifier | literal)
    INTO (qualifiedDataName [ROUNDED])+
end

## #############################################################################
## ENABLE statement.
## -----------------------------------------------------------------------------

def enableStatement =
    ENABLE (INPUT [TERMINAL] | I-O TERMINAL | OUTPUT)
            cdName [WITH] KEY (literal | identifier)
end

## #############################################################################
## ENTRY statement.
## -----------------------------------------------------------------------------

def entryStatement =
    ENTRY literal [mnemonicName]
        [ USING ( [[BY] (REFERENCE | VALUE)] (ANY | dataName [DELIMITED [BY SIZE]]) )+
            [REPEATED [integer TO integer]] ]
        [ (GIVING | RETURNING) dataName ]
end

## #############################################################################
## EVALUATE statement. Updated Adrian Noguero
## -----------------------------------------------------------------------------

def evaluateStatement =
    EVALUATE subject (ALSO subject)* 
    (when)+ 
    [whenOther]
    [END-EVALUATE]
end

def subject =
	(condition | arithmeticExpression | identifier | literal)
end


def when =
    ( WHEN object
      (ALSO object)*
    )+ 
    nestedStatements
end

def whenOther =
    WHEN OTHER
      nestedStatements
end

# Note: the order of the alternatives here is very important!
def object =
    ( ANY

    | rangeExpression

	| TRUE
	| FALSE
    | condition
    
    | [NOT] ( arithmeticExpression
            | identifier
            | literal
            )
    | '(' object ')'
    )
end

def rangeExpression =
  [NOT] 
  ( arithmeticExpression
  | identifier
  | literal
  )
  ( THROUGH | THRU )
  ( arithmeticExpression
  | identifier
  | literal
  )
end

## #############################################################################
## EXAMINE statement.
## -----------------------------------------------------------------------------

def examineStatement =
    EXAMINE identifier
    ( TALLYING (UNTIL FIRST | ALL | LEADING) literal [REPLACING BY literal]
    | REPLACING (ALL | LEADING | FIRST | UNTIL FIRST) literal BY literal
    )
end

# Ref:
# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDF904.html

## #############################################################################
## EXEC statement.
## -----------------------------------------------------------------------------

private def execStatement =
   ( execSQLStatement
   | execCICSStatement
   | execDLIStatement
   | execHTMLStatement
   | execTextDataStatement
   )
end

# EXEC SQL support. ------------------------------------------------------------
# This is supported by a separate grammar.

def execSQLStatement =
   (EXEC | EXECUTE) SQL 
     (--- [sqlStatement] --> END-EXEC) 
   END-EXEC
end

# EXEC CICS support. -----------------------------------------------------------

def execCICSStatement =
    (EXEC | EXECUTE) CICS
      (--- [cicsStatement] --> END-EXEC)
    END-EXEC
end

# EXEC DLI support. -----------------------------------------------------------

def execDLIStatement =
    (EXEC | EXECUTE) DLI
    [--> END-EXEC]
    END-EXEC
end

# EXEC HTML support. ----------------------------------------------------------

def execHTMLStatement =
    (EXEC | EXECUTE) HTML
    [--> END-EXEC]
    END-EXEC
end

# EXEC text-data support. -----------------------------------------------------

def execTextDataStatement =
    (EXEC | EXECUTE) textName
    [--> END-EXEC]
    END-EXEC
end

## #############################################################################
## EXIT statement.
## -----------------------------------------------------------------------------

def exitStatement =
    EXIT
    
    [( PROGRAM            # STD.BK
     | PARAGRAPH          # STD.BK
     | SECTION            # STD.BK
     | PERFORM [CYCLE]    # STD.BK
     | METHOD             # STD.BK
     | FUNCTION           # STD.BK
     | ITERATOR           # *.NET
     ) %as endpoint
    ]
    
    [returningPhrase]
end

def returningPhrase =
	(GIVING | RETURNING)
	(integer | ADDRESS OF identifier)
end

# Refs:
# MF. http://supportline.microfocus.com/documentation/books/nx60/lhpdf907.htm

## #############################################################################
## GENERATE statement.
## -----------------------------------------------------------------------------

def generateStatement =
    GENERATE (dataName | reportName)
end

## #############################################################################
## FREE statement.
## -----------------------------------------------------------------------------

# See https://sourceforge.net/p/open-cobol/manual/, page 6-53.

def freeStatement =
    FREE ( [ADDRESS [OF]] qualifiedDataName )+
end


## #############################################################################
## GOBACK statement.
## -----------------------------------------------------------------------------

def gobackStatement =
    GOBACK
        [(GIVING | RETURNING) ([ADDRESS OF] identifier | integer)]  # *MF
end

## #############################################################################
## GO TO statement.
## -----------------------------------------------------------------------------

def goToStatement =
    GO [TO] (procedureName)* [dependingOn]
end

def dependingOn =
    DEPENDING [ON] identifier
end

## #############################################################################
## IF statement.
## -----------------------------------------------------------------------------

def ifStatement =
    IF condition
      thenBranch
      [elseBranch]
    [END-IF]
end

def thenBranch =
    [THEN] (
      nestedStatements
    | (nextSentenceStatement %as statement) %as nestedStatements
    )
end

def elseBranch =
    ELSE (
      nestedStatements
    | (nextSentenceStatement %as statement) %as nestedStatements
    )
end


## #############################################################################
## INITIATE statement.
## -----------------------------------------------------------------------------

def initiateStatement =
    INITIATE (reportName)+
end

## #############################################################################
## INVOKE statement.
## -----------------------------------------------------------------------------

def invokeStatement =
    INVOKE identifier [AS (OBJECT | identifier)] (literal | identifier)
    
    [ USING ( [[BY] REFERENCE] ( ADDRESS OF identifier | OMITTED | literal | identifier )
            | [BY] CONTENT ( LENGTH OF identifier | arithmeticExpression | literal | identifier )
            | [BY] VALUE ( LENGTH OF identifier | integer SIZE [IS] integer | arithmeticExpression | integer | identifier )
            )+
    ]

    [ (GIVING | RETURNING) [INTO | ADDRESS OF] identifier ]
end

## #############################################################################
## EXHIBIT statement.
## -----------------------------------------------------------------------------

def exhibitStatement =
    EXHIBIT (NAMED | CHANGED NAMED | CHANGED) (identifier | literal)
end

# Ref:
# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDF906.html

## #############################################################################
## IDENTIFIED BY statement.
## -----------------------------------------------------------------------------

def identifiedByStatement =
    IDENTIFIED [BY] (dataName | literal) [[IS] ATTRIBUTE]
end

## #############################################################################
## INITIALIZE statement.
## -----------------------------------------------------------------------------

def initializeStatement =
	INITIALIZE
	(identifier)+
	[replacingInitClause]
	[--> (. | endOfStatement)]
end

def replacingInitClause =
	REPLACING
	replacementTarget
	[DATA] BY
	(identifier | literal)
end

def replacementTarget =
	(ALPHABETIC 
	|ALPHANUMERIC
	|ALPHANUMERIC-EDITED
	|NATIONAL
	|NATIONAL-EDITED
	|NUMERIC
	|NUMERIC-EDITED
	|DBCS
	|EGCS)
end

## #############################################################################
## INSPECT statement.
## -----------------------------------------------------------------------------

def inspectStatement =
	INSPECT identifier

	( convertingPhrase

    | tallyingPhrase
      [replacingPhrase]
      
	| replacingPhrase
    )
end

def convertingPhrase =
	CONVERTING
	(identifier | literal)
	TO
	(identifier | literal)
	(locationPhrase)*
end

def tallyingPhrase =
	TALLYING
	( qualifiedDataName FOR
	  ( tallyingCharactersPhrase
	  | tallyingAllLeadingOrTrailingPhrase
	  )*
	)*
end

def tallyingCharactersPhrase =
	CHARACTERS
	(locationPhrase)*
end

def tallyingAllLeadingOrTrailingPhrase =
	(ALL | LEADING | TRAILING)
	( (identifier -FOR | literal)
	  (locationPhrase)*
	)*
end

def replacingPhrase =
	REPLACING
	( replacingCharactersPhrase 
	| replacingAllLeadingFirstOrTrailingPhrase
	)*
end

def replacingCharactersPhrase =
	CHARACTERS BY
	(identifier | literal)
	(locationPhrase)*
end

def replacingAllLeadingFirstOrTrailingPhrase =
	(ALL | LEADING | FIRST | TRAILING)
	( (identifier | literal) BY (identifier | literal) (locationPhrase)* )*
end

def locationPhrase =
	(BEFORE | AFTER)
	[INITIAL]
	(identifier | literal)
end

## #############################################################################
## MERGE statement.
## -----------------------------------------------------------------------------

def mergeStatement =
    MERGE fileName
        ( [ON] (ASCENDING | DESCENDING) [KEY] [IS] (qualifiedDataName)+ )+
        [ [COLLATING] SEQUENCE [IS] alphabetName ]
        USING fileName (fileName)+
        ( OUTPUT PROCEDURE [IS] procedureName [(THROUGH | THRU) procedureName]
        | GIVING (fileName)+
        )
end

# Refs:
# http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFA01.html

## #############################################################################
## MOVE statement.
## -----------------------------------------------------------------------------

def moveStatement =
    MOVE 
      ( LENGTH [ OF ] identifier
      | [CORRESPONDING | CORR] identifier
      | literal
      )
    TO (identifier)+
    [--> (. | endOfStatement)]
end

## #############################################################################
## MULTIPLY statement.
## -----------------------------------------------------------------------------

def multiplyStatement =
    MULTIPLY ( multiplication_format1 | multiplication_format2 )
    [onSizeError]
    [notOnSizeError]
    [END-MULTIPLY]
end

# The order of these is important!

def multiplication_format1 =
    (identifier | literal)
    BY (identifier | literal)
    GIVING (qualifiedDataName [ROUNDED])+
end

def multiplication_format2 =
    (identifier | literal)
    BY (qualifiedDataName [ROUNDED])+
end

## #############################################################################
## NEXT SENTENCE statement.
## -----------------------------------------------------------------------------

def nextSentenceStatement =
    NEXT SENTENCE
end

## #############################################################################
## ON statement.
## -----------------------------------------------------------------------------

def onStatement =
    ON (literal | identifier)
        [ AND EVERY (literal | identifier) ]
        [ UNTIL (literal | identifier) ]
        ( nestedStatements
        | NEXT SENTENCE
        )
        [ (ELSE | OTHERWISE)
            ( nestedStatements
            | NEXT SENTENCE
            )
        ]
end

# Refs:
# OS/VS: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFA06.html

## #############################################################################
## OPEN statement.
## -----------------------------------------------------------------------------

def openStatement =
    OPEN
    ( INPUT (fileName [REVERSED | [WITH] NO REWIND])+
    | OUTPUT (fileName [[WITH] NO REWIND])+
    | I-O (fileName)+
    | EXTEND (fileName)+
    )+
end

## #############################################################################
## PERFORM statement.
## -----------------------------------------------------------------------------

# The order here is important! If you want to correctly recognize:
#   PERFORM 7 TIMES  ...
# Then you need to check in-line first. If not, the parser will understand the
# number as a procedureName (yes, 7 is a valid procedure name).
#
# *ANS85: If procedureName is omitted, nestedStatements and the END-PERFORM phrase
#         must be specified; if procedureName is specified, nestedStatements and
#         the END-PERFORM phrase must not be specified.
#
# *MF: When statement is specified, the END-PERFORM phrase is optional.

def performStatement =
    PERFORM 
    ( # Perform inline, without procedureName
        [ times
        | until
        | varying
        ]
        ( nestedStatements END-PERFORM
        | statement %as nestedStatements   -THRU -THROUGH
        | END-PERFORM 
        )
        
    | # Perform procedureName
        procedureName [(THROUGH | THRU) procedureName]
        [ times
        | until
        | varying
        ]
        
    | # Perform inline with VARYING
        VARYING identifier THROUGH identifier
        nestedStatements
        END-PERFORM
    )
end

# Refs:
# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFB01.html

def times =
    (identifier | integer) TIMES
end

def testPosition =
	[WITH] TEST (BEFORE | AFTER)
end

def until =
    [testPosition]
    UNTIL (condition | EXIT)
end

# The documentation also explicitly mentions indices. Matching these, however,
# requires tracking their definition in the data section. This is something we
# don't do. This doesn't matter that much, as indices are a degenerate form of
# identifiers, which we are able to match. So the catch is that while we do
# match indices it is up to the end-user to distinguish them from identifiers.

def varying =
    [testPosition]
    
    VARYING (identifier)
        FROM (literal | identifier)
        BY (literal | identifier)
        UNTIL condition
    
    (AFTER (identifier)
        FROM (literal | identifier)
        BY (literal | identifier)
        UNTIL condition
    )*
end

## #############################################################################
## PURGE statement.
## -----------------------------------------------------------------------------

def purgeStatement =
    PURGE cdName
end

## #############################################################################
## RAISE statement.
## -----------------------------------------------------------------------------

def raiseStatement =
    RAISE [ identifier ]
end

## #############################################################################
## READ statement.
## -----------------------------------------------------------------------------

def readStatement =
    READ fileName
    
    [NEXT | PREVIOUS] [RECORD] [INTO identifier_format2]
    
    [ ADVANCING [ON] LOCK
    | IGNORING LOCK
    | [WITH] ( [KEPT | NO | IGNORE] LOCK
             | WAIT
             )
    | retryPhrase
    ]
    
    [KEY [IS] qualifiedDataName]
    
    [atEnd]
    [notAtEnd]
    
    [invalidKey]
    [notInvalidKey]
    
    [END-READ]
end

def readWithClause =
    [WITH] (readLockClause | WAIT)
end

def readLockClause =
    [KEPT | NO | IGNORE] LOCK
end


## #############################################################################
## READY TRACE statement.
## -----------------------------------------------------------------------------

def readyTraceStatement =
    READY TRACE [.]
end

## #############################################################################
## RECEIVE statement.
## -----------------------------------------------------------------------------

def receiveStatement =
    RECEIVE 
    ( dataName FROM ( THREAD dataName | LAST THREAD | ANY THREAD )
      ![ BEFORE [TIME] (numeric | identifier)
       | [WITH] NO WAIT
       | THREAD     [IN] dataName
       | SIZE       [IN] (numeric | identifier)
       | STATUS     [IN] (alphanumericLiteral | identifier)
       | onException
       | notOnException
       ]                                                                # *ACU
    | cdName (MESSAGE | SEGMENT) [INTO] identifier
       [noData]
       [withData]
    )
    [END-RECEIVE]
end

def noData =
    NO DATA nestedStatements
end

def withData =
    WITH DATA nestedStatements
end


## #############################################################################
## RELEASE statement.
## -----------------------------------------------------------------------------

def releaseStatement =
    RELEASE recordName [FROM identifier]
end

## #############################################################################
## RESET TRACE statement.
## -----------------------------------------------------------------------------

def resetTraceStatement =
    RESET TRACE [.]
end

## #############################################################################
## RETURN statement.
## -----------------------------------------------------------------------------

def returnStatement =
    RETURN fileName [RECORD] [INTO identifier] 
    atEnd 
    [notAtEnd]
    [END-RETURN]
end

## #############################################################################
## REWRITE statement.
## -----------------------------------------------------------------------------

def rewriteStatement =
    REWRITE recordName [FROM (identifier | literal)]
    
    [retryPhrase]
    
    [[WITH] [NO] LOCK]
    
    [invalidKey]
    [notInvalidKey]
    
    [END-REWRITE]
end

## #############################################################################
## ROLLBACK statement.
## -----------------------------------------------------------------------------

def rollbackStatement =
    ROLLBACK
end

# Refs:
# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFB06.html

## #############################################################################
## SEARCH statement.
## -----------------------------------------------------------------------------

def searchStatement =
    SEARCH 
    ( ALL identifier
    | identifier [VARYING (identifier | indexName)]
    )
   
    [atEnd]
   
    (( WHEN condition
       ( nestedStatements
       | NEXT SENTENCE
       )
     ) %as when
    )+ 
   
    [END-SEARCH]
end

def atEnd =
    [AT] END nestedStatements
end

def notAtEnd =
    NOT [AT] END nestedStatements
end

## #############################################################################
## SEND statement.
## -----------------------------------------------------------------------------

def sendStatement =
    SEND
    ( dataName TO ( LAST THREAD
                  | ALL THREADS
                  | ([THREAD] dataName)+
                  )                                                     # *ACU
    | cdName [FROM identifier]
           [ [WITH] (ESI | EMI | EGI | identifier)
             [(BEFORE | AFTER) [ADVANCING] ( PAGE
                                           | (zero | integer | identifier) [LINE | LINES]
                                           | mnemonicName
                                           )
             ]
             [REPLACING [LINE]]
           ]
    )
end

## #############################################################################
## SERVICE statement. OS/VS and VS COBOL II.
## -----------------------------------------------------------------------------

def serviceStatement =
    SERVICE (LABEL | RELOAD identifier)
end

# Refs:
# http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFC02.html

## #############################################################################
## SORT statement.
## -----------------------------------------------------------------------------

def sortStatement =
    ( # File format
        SORT fileName
        ( ON ( (ASCENDING | DESCENDING) [KEY] [IS] (qualifiedDataName)+ )+ )+
        [ [WITH] DUPLICATES [IN ORDER] ]
        [ [COLLATING] SEQUENCE [IS] alphabetName ]
        
        ( INPUT PROCEDURE [IS] procedureName [(THROUGH | THRU) procedureName]
        | USING (fileName)+
        )
        
        ( OUTPUT PROCEDURE [IS] procedureName [(THROUGH | THRU) procedureName]
        | GIVING (fileName)+
        )
        
    | # Data format
        SORT dataName
        ( ON ( (ASCENDING | DESCENDING) [KEY] [IS] (qualifiedDataName)+ )+ )+
        [ [WITH] DUPLICATES [IN ORDER] ]
        [ [COLLATING] SEQUENCE [IS] alphabetName ]
    )
end

# Refs:
# http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFC04.html

## #############################################################################
## SET statement.
## -----------------------------------------------------------------------------

def setStatement =
    SET
    ( setEnvironmentVariable
    | setFormatMonitorValue
    | setFormatDataPointerAssignment
    | setFormatProcedurePointerAssignment
    | setFormatSemaphoreValue
    | setFormat1
    | setFormat2
    | setFormat3
    )
    [--> (. | endOfStatement)]
end

def setFormat1 =
	(indexName | identifier)+
	TO
	(indexName | identifier | integer)
end

def setFormat2 =
	(mnemonicName)+
	TO
	(ON | OFF)
end

def setFormat3 =
	(identifier)+
	TO
	(TRUE | FALSE)
end

def setFormatDataPointerAssignment =
    (ADDRESS [OF] identifier | identifier)+
    TO
    (ADDRESS [OF] identifier | mnemonicName | NULL | NULLS)
end

def setFormatProcedurePointerAssignment =
    procedureName
    TO
    (procedureName | ENTRY (identifier | literal) | NULL | NULLS)
end

def setFormatMonitorValue =
    (mnemonicName)+
    TO [NOT] (BROWSING | READING | WRITING)
    [CONVERTING FROM (BROWSING | WRITING)]
end

def setFormatSemaphoreValue =
    (mnemonicName)+
    TO
    (UP | DOWN)
    BY
    (integer | identifier)
end

# Based on a sample found in the wild...
def setEnvironmentVariable =
    ENVIRONMENT literal TO literal
end

# Refs:
# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFC03.html

## #############################################################################
## START statement.
## -----------------------------------------------------------------------------

# TODO So far a skeletal implementation only.
def startStatement =
    START fileName
    
    [keyModifier]
    [sizeModifier]
    [whileKeyModifier]
    
    [invalidKey]
    [notInvalidKey]
    
    [END-START]
end

def keyModifier =
	KEY [IS] (relop | FIRST | LAST) identifier (IN identifier)*
end

def sizeModifier =
	[WITH] SIZE (identifier | integer)
end

def whileKeyModifier =
	WHILE [KEY [IS]] [NOT] LIKE (likeMods)* (identifier | literal)
end

def likeMods =
	(trimmedRight
	|trimmedLeft
	|caseSensitive
	|caseInsensitive)
end

def trimmedRight =
	TRIMMED RIGHT
end

def trimmedLeft =
	TRIMMED LEFT
end

def caseSensitive =
	CASE-SENSITIVE
end

def caseInsensitive =
	CASE-INSENSITIVE
end

## #############################################################################
## STOP statement.
## -----------------------------------------------------------------------------

def stopStatement =
    STOP

    ( RUN %as endpoint
      [ # MF
        (GIVING | RETURNING)
        ( [ADDRESS OF] identifier
        | integer [SIZE [IS] integer]
        )

      | # STD.BK
        [WITH] (ERROR | NORMAL) [STATUS] [identifier | literal]        
      ]

    | # MF .NET/JVM
      ITERATOR %as endpoint

    | # ANSI 85
      literal
    )
end

# Refs:
# http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFC06.html


## #############################################################################
## STRING statement.
## -----------------------------------------------------------------------------

def stringStatement =
    STRING
    ( ( identifier | literal ) [DELIMITED [BY] (SIZE | identifier | literal)] )+
    INTO identifier [[WITH] POINTER identifier]
    [onOverflow]
    [notOnOverflow]
    [END-STRING]
end

## #############################################################################
## SUBTRACT statement.
## -----------------------------------------------------------------------------

def subtractStatement =
    SUBTRACT ( subtraction_format1 | subtraction_format2 | subtraction_format3 )
    [onSizeError]
    [notOnSizeError]
    [END-SUBTRACT]
end

def subtraction_format1 =
    (CORRESPONDING | CORR) identifier FROM identifier [ROUNDED]
end

def subtraction_format2 =
    (identifier | literal)+
    [FROM (identifier | literal)]
    GIVING (identifier [ROUNDED])+
end

def subtraction_format3 =
    (identifier | literal)+
    FROM (identifier [ROUNDED])+
end

## #############################################################################
## SUPPRESS statement.
## -----------------------------------------------------------------------------

def suppressStatement =
    SUPPRESS [PRINTING]
end

## #############################################################################
## TERMINATE statement.
## -----------------------------------------------------------------------------

def terminateStatement =
    TERMINATE (reportName)+
end

## #############################################################################
## TRANSFORM statement. Micro Focus COBOL.
## -----------------------------------------------------------------------------

def transformStatement =
    TRANSFORM identifier [CHARACTERS]
    FROM (figurativeConstant | alphanumericLiteral | identifier)
    TO (figurativeConstant | alphanumericLiteral | identifier)
end

# Refs:
# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFC09.html

## #############################################################################
## UNLOCK statement. Micro Focus COBOL.
## -----------------------------------------------------------------------------

def unlockStatement =
    UNLOCK fileName [RECORD | RECORDS]
end

# Refs:
# MF: http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.enterprisedeveloper.vs%2FHRLHLHPDFC0A.html

## #############################################################################
## UNSTRING statement.
## -----------------------------------------------------------------------------

def unstringStatement =
    UNSTRING identifier
    
    [ DELIMITED [BY] [ALL] (identifier | literal)
      ( OR [ALL] (identifier | literal) )*
    ]
    
    INTO (
      identifier
      [DELIMITER [IN] identifier]
      [COUNT [IN] identifier]
    )+
    
    [[WITH] POINTER identifier]
    [TALLYING [IN] identifier]
    
    [onOverflow]
    [notOnOverflow]
    [END-UNSTRING]
end

## #############################################################################
## USE statement (by Adrian Noguero).
## -----------------------------------------------------------------------------

def useStatement =
	USE 
	( errorDeclarative
	| debugDeclarative
	| labelDeclarative
    | beforeReportingDeclarative)
end

def errorDeclarative =	
	[GLOBAL] AFTER [STANDARD]
	( ERROR | EXCEPTION )
	PROCEDURE [ON]
	( INPUT
	| OUTPUT
	| I-O
	| EXTEND
	| (fileName)*
    )
    [GIVING dataName [dataName]]
end

def debugDeclarative =
	[FOR] DEBUGGING [ON]
	( ALL PROCEDURES
	| [ALL [REFERENCES] [OF]] identifier
    | procedureName
    | fileName
    )*
end

def labelDeclarative =
	[GLOBAL] AFTER [STANDARD]
	[ BEGINNING | ENDING ]
	[ FILE | REEL | UNIT ]
	LABEL PROCEDURE [ON]
	( INPUT
	| OUTPUT
	| I-O
	| EXTEND
	| (fileName)*
    )
end

def beforeReportingDeclarative =
    [GLOBAL] BEFORE REPORTING identifier
end

## #############################################################################
## WAIT statement. Micro Focus COBOL.
## -----------------------------------------------------------------------------

def waitStatement =
    ( WAIT [FOR] threadPointer
        [RETURNING [INTO] identifier]
        [STATUS [IS] identifier]
        [onException]
        [notOnException]
        [END-WAIT]
    | WAIT [FOR] eventPointer
    )
end

## #############################################################################
## WRITE statement.
## -----------------------------------------------------------------------------

def writeStatement =
    WRITE recordName [FROM (identifier | literal)]
    
    [ (AFTER | BEFORE) [ADVANCING | POSITIONING]
      ( (identifier | integer | zero) [LINE | LINES]
      | mnemonicName
      | PAGE
      | TAB                 # *MF
      | FORMFEED            # *MF
      )
    ]
    
    [atEndOfPage]
    [notAtEndOfPage]

    [retryPhrase]

    [[WITH] [NO] LOCK]
    
    [invalidKey]
    [notInvalidKey]
    
    [END-WRITE]
end

def atEndOfPage =
    [AT] (END-OF-PAGE | EOP) nestedStatements
end

def notAtEndOfPage =
    NOT [AT] (END-OF-PAGE | EOP) nestedStatements
end


## #############################################################################
## XML GENERATE statement.
## -----------------------------------------------------------------------------

# Based on "Cobol zOS Language Reference".
def xmlGenerateStatement =
    XML GENERATE identifier FROM identifier
    [COUNT [IN] identifier]
    [[WITH] ENCODING cobolWord]
    [[WITH] XML-DECLARATION]
    [[WITH] ATTRIBUTES]
    [NAMESPACE [IS] (identifier | literal)
       [NAMESPACE-PREFIX [IS] (identifier | literal)]
    ]
    [onException]
    [notOnException]
    [END-XML]
end

## #############################################################################
## XML PARSE statement.
## -----------------------------------------------------------------------------

def xmlParseStatement =
    XML PARSE identifier
    [PROCESSING PROCEDURE [IS] procedureName]
        [(THROUGH | THRU) procedureName]
    [onException]
    [notOnException]
    [END-XML]
end

## #############################################################################
## Controlling the compiler.
## -----------------------------------------------------------------------------

def compilerStatement =
    ( compilerDirective
    | compilerIfStatement
    | compilerDisplayStatement
    | copyStatement
    | replaceStatement
    | useStatement .
    )
end

def compilerDirective =
    ('\u0024' SET)
    (--> ('\u0024' SET | divisionStart | sourceUnit | verb))
end

def compilerIfStatement =
    '\u0024' IF operand [ SET | [NOT] DEFINED | [NOT] ('<' | '>' | '=') operand ]
        # FIXME: Anything can go inside an $IF condition.
        (compilerStatement | nestedStatements)
    ['\u0024' ELSE
        # FIXME: Anything can go inside an $IF condition.
        (compilerStatement | nestedStatements)
    ]
    '\u0024' END
end

def compilerDisplayStatement =
    '\u0024' DISPLAY ( VCS '=' literal | textName )
end

# This overrides the CobolPreprocessing definition.
def copyOperandName =
	([LEADING | TRAILING] pseudoLiteral | verb | literal | identifier | cobolWord)
end

def replaceStatement =
    REPLACE
    ( OFF
    | ( pseudoLiteral BY pseudoLiteral
      | (LEADING | TRAILING) pseudoLiteral BY pseudoLiteral
      )+
    ) [.]
end


## #############################################################################
## Source formatting directives.
## TODO Merge this somehow with the SourceFormattingDirectivesFilter.
## -----------------------------------------------------------------------------

def sourceFormattingDirective =
    ( ejectStatement
    | skipStatement
    | titleStatement
    )
end

def ejectStatement =
    EJECT [.]
end

def skipStatement =
    (SKIP1 | SKIP2 | SKIP3) [.]
end

def titleStatement =
    TITLE literal [.]
end


## #############################################################################
## Lookaheads used for skipping.
## -----------------------------------------------------------------------------

def divisionStart =
    ( (ID | IDENTIFICATION) DIVISION
    | ENVIRONMENT DIVISION
    | DATA DIVISION
    | PROCEDURE DIVISION [usingOrChainingPhrase] [returningProcedurePhrase]
    )
    .
end

def sectionStart =
    ( CONFIGURATION
    | INPUT-OUTPUT
    | FILE
    | WORKING-STORAGE
    | THREAD-LOCAL-STORAGE
    | OBJECT-STORAGE
    | LOCAL-STORAGE
    | LINKAGE
    | COMMUNICATION
    | OBJECT
    | REPORT
    | SCREEN
    ) SECTION .
end

def paragraphStart =
    ( SOURCE-COMPUTER
    | OBJECT-COMPUTER 
	| SPECIAL-NAMES
    | REPOSITORY
    | CONSTRAINTS
    | CLASS-ATTRIBUTES
    | ASSEMBLY-ATTRIBUTES
    | FILE-CONTROL
    | I-O-CONTROL
    | CLASS-CONTROL
    ) .
end

# End of a (nested) statement.
def endOfStatement =
    ( verb
    
    | ELSE             # IF statement
    | WHEN             # SEARCH, EVALUATE statement

    | END-ACCEPT
    | END-ADD
    | END-CALL
    | END-CHAIN        # *MF
    | END-COMPUTE
    | END-DELETE
    | END-DISPLAY
    | END-DIVIDE
    | END-EVALUATE
    | END-EXEC
    | END-IF
    | END-MULTIPLY
    | END-PERFORM
    | END-READ
    | END-RECEIVE
    | END-RETURN
    | END-REWRITE
    | END-SEARCH
    | END-START
    | END-STRING
    | END-SUBTRACT
    | END-UNSTRING
    | END-WAIT          # *MF
    | END-WRITE
    | END-XML           # *MF

    | [NOT] [ON | AT]
      ( OVERFLOW       # CALL statement
      | EXCEPTION      # CALL statement
      | SIZE ERROR
      | INVALID [KEY]
      | END            # RETURN statement
      | END-OF-PAGE
      | EOP
      )
    )
end

## #############################################################################
## Identifiers.
## -----------------------------------------------------------------------------

# TODO Qualifiers, subscripts and reference modifiers.

def function = 
    FUNCTION
    ( ABS                   '(' argument ')'                    # *MF *OC
    | ACOS                  '(' argument ')'                    # *ANS85
    | ANNUITY               '(' argument argument ')'           # *ANS85
    | ASIN                  '(' argument ')'                    # *ANS85
    | ATAN                  '(' argument ')'                    # *ANS85
    | BOOLEAN-OF-INTEGER    '(' argument argument ')'
    | BYTE-LENGTH           '(' argument ')'                    # *OC
    | CHAR                  '(' argument ')'                    # *ANS85
    | CHAR-NATIONAL         '(' argument ')'                    # *ISO2002 *MF
    | COMBINED-DATETIME     '(' argument argument ')'           # *OC
    | CONCATENATE           '(' (argument)+ ')'                 # *OC
    | COS                   '(' argument ')'                    # *ANS85
    | CURRENT-DATE                                              # *OC
    | DATE-OF-INTEGER       '(' argument ')'                    # *ANS85
    | DATE-TO-YYYYMMDD      '(' argument [argument] ')'         # *ANS85
    | DAY-OF-INTEGER        '(' argument ')'                    # *ANS85
    | DAY-TO-YYYYDDD        '(' argument [argument] ')'         # *ANS85
    | DISPLAY-OF            '(' argument [argument] ')'         # *ISO2002 *MF
    | E                                                         # *MF *OC
    | EXCEPTION-FILE                                            # *OC
    | EXCEPTION-LOCATION                                        # *OC
    | EXCEPTION-STATEMENT                                       # *OC
    | EXCEPTION-STATUS                                          # *OC
    | EXP                   '(' argument ')'                    # *MF *OC
    | EXP10                 '(' argument ')'                    # *MF *OC
    | FACTORIAL             '(' argument ')'                    # *ANS85
    | FRACTION-PART         '(' argument ')'                    # *MF *OC
    | INTEGER               '(' argument ')'                    # *ANS85
    | INTEGER-OF-BOOLEAN    '(' argument ')'
    | INTEGER-OF-DATE       '(' argument ')'                    # *ANS85
    | INTEGER-OF-DAY        '(' argument ')'                    # *ANS85
    | INTEGER-PART          '(' argument ')'                    # *ANS85
    | LENGTH                '(' argument ')'                    # *ANS85
    | LENGTH-AN             '(' argument ')'                    # *MF
    | LOCALE-DATE           '(' argument [argument] ')'         # *OC
    | LOCALE-TIME           '(' argument [argument] ')'         # *OC
    | LOCALE-TIME-FROM-SECS '(' argument [argument] ')'         # *OC
    | LOG                   '(' argument ')'                    # *ANS85
    | LOG10                 '(' argument ')'                    # *ANS85
    | LOWER-CASE            '(' argument ')'                    # *ANS85
    | MAX                   '(' (argument)+ ')'                 # *ANS85
    | MEAN                  '(' (argument)+ ')'                 # *ANS85
    | MEDIAN                '(' (argument)+ ')'                 # *ANS85
    | MIDRANGE              '(' (argument)+ ')'                 # *ANS85
    | MIN                   '(' (argument)+ ')'                 # *ANS85
    | MOD                   '(' argument argument ')'           # *ANS85
    | NATIONAL-OF           '(' argument [argument] ')'         # *ISO2002 *MF
    | NUMVAL                '(' argument ')'                    # *ANS85
    | NUMVAL-C              '(' argument [argument] ')'         # *ANS85
    | ORD                   '(' argument ')'                    # *ANS85
    | ORD-MAX               '(' (argument)+ ')'                 # *ANS85
    | ORD-MIN               '(' (argument)+ ')'                 # *ANS85
    | PI                                                        # *MF *OC
    | PRESENT-VALUE         '(' argument (argument)+ ')'        # *ANS85
    | RANDOM                [ '(' argument ')' ]                # *ANS85
    | RANGE                 '(' (argument)+ ')'                 # *ANS85
    | REM                   '(' argument argument ')'           # *ANS85
    | REVERSE               '(' argument ')'                    # *ANS85
    | SECONDS-FROM-FORMATTED-TIME
                            '(' argument argument ')'           # *OC
    | SECONDS-PAST-MIDNIGHT                                     # *OC
    | SIGN                  '(' argument ')'                    # *ANS85
    | SIN                   '(' argument ')'                    # *ANS85
    | SQRT                  '(' argument ')'                    # *ANS85
    | STANDARD-DEVIATION    '(' (argument)+ ')'                 # *ANS85
    | STORED-CHAR-LENGTH    '(' argument ')'                    # *OC
    | SUBSTITUTE            '(' (argument)+ ')'                 # *OC
    | SUBSTITUTE-CASE       '(' (argument)+ ')'                 # *OC
    | SUM                   '(' (argument)+ ')'                 # *ANS85
    | TAN                   '(' argument ')'                    # *ANS85
    | TEST-DATE-YYYYMMDD    '(' argument ')'                    # *OC
    | TEST-DAY-YYYYDDD      '(' argument ')'                    # *OC
    | TRIM                  '(' argument [LEADING|TRAILING] ')' # *OC
    | UPPER-CASE            '(' argument ')'                    # *ANS85
    | VARIANCE              '(' (argument)+ ')'                 # *ANS85
    | WHEN-COMPILED                                             # *ANS85
    | YEAR-TO-YYYY          '(' argument [argument] ')'         # *ANS85
    | functionName          [ '(' (argument)+ ')' ]
    )
end

def identifier =
    ( identifier_format6
    | identifier_format1
    | identifier_format2
    | dataAddressIdentifier
    )
end

def identifier_format1 =
    function [referenceModifier]
end

def identifier_format2 =
    qualifiedDataName [referenceModifier]
end

# Cfr. ISO/IEC 1989:20xx FCD 1.0 (E), 8.4.2.1.1

def identifier_format6 =
    ( EXCEPTION-OBJECT
    | NULL
    | SELF
    | [ className OF ] SUPER
    )
end

def dataAddressIdentifier =
	ADDRESS [OF] identifier
end

def argument =
    ( arithmeticExpression
    | identifier
    | literal
    )
end

def qualifier =
    ((IN | OF) dataName)+
end

def subscript =
    # The order is important here ! Relative and direct subscripts overlap
    # somewhat. A direct may be a simple dataName; a relative a dataName
    # followed by an offset. If we matched the direct first we would never
    # check for the offset.
    ( relativeSubscript
    | directSubscript
    )
end

def directSubscript =
    # The order is important here ! Cobol words, when they are integer
    # constants, count as integers. But because Koopa cannot verify the type
    # of a given Cobol word it accepts all Cobol words as integers. So
    # integer would match any Cobol word, making it impossible for other cases
    # to get a chance at matching the input. 
    ( ALL
    | identifier
    | integer
    )
end

def relativeSubscript =
    identifier ('+' | '-') integer
end

def referenceModifier =
    '(' arithmeticExpression ':' [arithmeticExpression] ')'
end

## #############################################################################
## Arithmetic expressions. Rewritten Adrian Noguero
## -----------------------------------------------------------------------------

# FIXME: A single numeric/identifier is considered an arithmeticExpression by this grammar.

def arithmeticExpression =
    bitwiseOperand (bitwiseOperator bitwiseOperand)*
end

def bitwiseOperator =
    (B-AND | B-OR | B-XOR | B-EXOR)
end

def bitwiseOperand =
    summand (signDef summand)*
end

def signDef =
	('+' | '-')
end

def summand =
    factor (('*' | '/') factor)*
end

def unaryOperator =
    ('+' | '-' | B-NOT)
end

def factor =
    [unaryOperator] atomicExpression ('**' [unaryOperator] atomicExpression)*
end

# TODO: Check sources for use of ZERO in this case.
def atomicExpression =
    ( zero
    | identifier
    | numeric
    | '(' arithmeticExpression ')'
    )
end

## #############################################################################
## Conditions.
## -----------------------------------------------------------------------------

# The parsing of conditions does not try to build correct parse trees; well,
# "not correct" in the sense that you get something immediately usable for
# analysis or intepretation/compilation.
#
# Here is an example of what I mean. Given following condition:
#
#     A < B AND C < D
#
# Ideally you want a parse tree which looks like this:
#
#     _   AND   _
#   _ < _     _ < _
#   A   B     C   D
#
# Instead what we do is something like:
#
#   A   ___    _____    ___
#       < B    AND C    < D
#
# So you get a series of parts which make up the condition.
#
# Why do it this way ? Because without type information and lookup tables we
# can only guess at the semantics of some identifiers. This makes the structure
# of conditions a mess of ambiguity, and the grammar to match conditions
# equally so.

def condition =
	[NOT] (
	  conditionStart
	| '(' condition ')'
	)
	(furtherCondition)*
end

def conditionStart =
	(
	  TRUE
	| FALSE
	| operand
	)
end

def furtherCondition =
	( TRUE
	| FALSE
	| [IS] [NOT] OMITTED
	| [IS] [NOT] classType
	| [IS] [NOT] signType
	| [AND | OR] [IS] [NOT] [relop] operand
	| [AND | OR] [IS] [NOT] [relop] '(' condition ')'
	)
end

def classType =
	( NUMERIC
	| ALPHABETIC
	| ALPHABETIC-LOWER
	| ALPHABETIC-UPPER
	| DBCS
	| KANJI
	| BOOLEAN
	| INFINITY
	| REPRESENTS-NOT-A-NUMBER
	)
end

def signType =
	( POSITIVE
	| NEGATIVE
	| zero
	)
end

def relop =
	[IS | ARE]
	( [NOT] greaterOrEqualOp
	| [NOT] lessOrEqualOp
	| [NOT] greaterThanOp
	| [NOT] lessThanOp
	| [NOT] equalToOp
    | exceedsOp
    | equalsOp
	| unequalToOp)
end

def greaterThanOp =
	(GREATER [THAN] | '>')
end

def lessThanOp =
	(LESS [THAN] | '<')
end

def equalToOp =
	(EQUAL [TO] | '=')
end

def exceedsOp =
    EXCEEDS
end

def equalsOp =
    EQUALS
end

def unequalToOp =
	( UNEQUAL [TO]
    | '<>'
    )
end

def greaterOrEqualOp =
	(GREATER [THAN] OR EQUAL [TO] | '>=')
end

def lessOrEqualOp =
	(LESS [THAN] OR EQUAL [TO] | '<=')
end 


## #############################################################################
## Low level stuff.
## -----------------------------------------------------------------------------

# Program name.
#
# "[A] program-name can be specified either as a user-defined word or in an
# alphanumeric literal. Either way, program-name must follow the rules for
# forming a user-defined word. program-name cannot be a figurative constant.
# Any lowercase letters in the literal are folded to uppercase."
#
# Src: "COBOL for AIX, V3.1"
# http://publib.boulder.ibm.com/infocenter/comphelp/v101v121/index.jsp?topic=/com.ibm.aix.cbl.doc/PGandLR/ref/rlprg.htm
#
def programName =
	( cobolWord
	| alphanumeric
	)
end

# Data name.
def dataName =
	cobolWord
end

# Full Qualified Data name with subscripts.
def qualifiedDataName =
	dataName [qualifier] ['(' (subscript)+ ')']
end

def screenName =
    cobolWord
end

# Section name.
def sectionName =
	name
end

# Paragraph name.
def paragraphName =
	name
end

# "A procedure-name is a word used to refer to a paragraph or section in the 
# source element in which it occurs. It consists of a paragraph-name (that may 
# be qualified) or a section-name."
# -- ISO/IEC 1989:20xx FCD 1.0 (E); section 14.4
def procedureName =
    name [ ( IN | OF ) sectionName	]
end

def name =
	( cobolWord
	| integer
	)
end

# Segment number.
def segmentNumber =
    # TODO Should be two digits only. 
    integer
end

# TODO Arithmetic expression will (likely) capture all other cases as well. Can
# we disambiguate this further ? 
def operand =
	( arithmeticExpression
	| identifier
	| literal
	| indexName
	)
end

def threadPointer =
    cobolWord
end

def eventPointer =
    cobolWord
end

def conditionName =
	identifier
end 

def indexName =
    cobolWord
end

def className =
	cobolWord
end

def typeSpecifier =
    cobolWord
end

def parameterName =
	cobolWord
end

def interfaceName =
	cobolWord
end

def methodName =
	cobolWord
end

def propertyName =
    ( identifier
    | alphanumeric
    )
end

def propertyValue =
    ( identifier
    | literal
    )
end

def delegateName =
    cobolWord
end

def iteratorName =
    cobolWord
end

def enumName =
    cobolWord
end

def valuetypeName =
    cobolWord
end

def typeName = 
    cobolWord
end

def attributeName =
	cobolWord
end

def typedefName =
	cobolWord
end

def fileName =
    ( cobolWord
    | alphanumeric
    )
end

def computerName =
	cobolWord
end

def functionName =
    cobolWord
end

def recordName =
    identifier
end

def mnemonicName =
    (identifier | cobolWord)
end

def environmentName =
	( SYSIN
	| SYSIPT
	| SYSOUT
	| SYSLIST
	| SYSLST
	| SYSPUNCH
	| SYSPCH
	| CONSOLE
    | CRT
    | CRT-UNDER
	| C01
	| C02
	| C03
	| C04
	| C05
	| C06
	| C07
	| C08
	| C09
	| C10
	| C11
	| C12
	| CSP
	| S01
	| S02
	| S03
	| S04
	| S05
	| AFP-5A
    )
end

def alphabetName =
    cobolWord
end

def cdName =
    cobolWord
end

def reportName =
    cobolWord
end

def literal =
    # Ideally 'constant' would be an option of 'literalValue' and then the
    # first option here would be sufficient. However, as Koopa does not
    # maintain a symbol table or list of defined constants the definition of
    # 'constant' is by necessity too liberal. To prevent this from carrying
    # over I split up the definition of literal so that if it matches only a
    # single token that token can not just be a constant.
    #
    # If/When this causes problems I would suggest looking at the option of
    # a symbol table rather than making the grammar even more complex...
     
    ( literalValue (concatenatedLiteral)*
    | constant (concatenatedLiteral)+
    )
end

def literalValue =
    ( numericLiteral
    | alphanumericLiteral

    # According to my documentation a figurative constant can appear anywhere a
    # literal can, except for a few edge cases. I'll ignore the edge cases here.
    | figurativeConstant
    
    # TODO Correct ?
    | TRUE
    | FALSE
    )
end

def concatenatedLiteral =
    '&' (literalValue | constant)
end

def value =
	( literal
	| integerConstant
	| alphanumericConstant
	)
end

# TODO [ALL] symbolic-character
def figurativeConstant =
    ( ALL literal
    | [ALL]
      ( zero 
      | space
      | HIGH-VALUE 
      | HIGH-VALUES 
      | LOW-VALUE 
      | LOW-VALUES 
      | QUOTE
      | QUOTES
      )
    | NULL
    | NULLS
    )
end

def numericLiteral =
    ( decimal
    | integerLiteral
    | booleanLiteral
    | hexadecimal
    | (LENGTH | BYTE-LENGTH) [OF] identifier
    )
end

def numeric =
    ( decimal
    | integer
    | booleanLiteral
    | hexadecimal
    | zero
    | (LENGTH | BYTE-LENGTH) [OF] identifier
    )
end

def integer =
    ( integerLiteral
    | integerConstant
    )
end

def constant =
    ( integerConstant
    | alphanumericConstant
    )
end

# Ideally we should check if the cobolWord actually is an integer constant.
# This is, however, outside the current scope of Koopa.
def integerConstant =
    cobolWord
end

def alphanumeric =
    ( alphanumericLiteral
    | alphanumericConstant
    )
end

# Ideally we should check if the cobolWord actually is an alphanumeric constant.
# This is, however, outside the current scope of Koopa.
def alphanumericConstant =
    cobolWord
end

# -----------------------------------------------------------------------------
# Decimals
#
# Whether we're working on a decimal is something which can only be decided at
# parsing time. But it does require some lexer info.
#
# TODO Allow ",2"; which is still tricky.
def decimal =
    ( intgr %noskip ( (',' | '.') uintgr )
    | '.' %noskip uintgr
    )
end

def intgr =
    @INTEGER_LITERAL _
end

def uintgr =
    @UNSIGNED @INTEGER_LITERAL _
end

