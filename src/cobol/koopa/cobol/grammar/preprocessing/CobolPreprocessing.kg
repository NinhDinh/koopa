grammar CobolPreprocessing extends CobolPreprocessingBase.

## #############################################################################
## Top level definitions.
## -----------------------------------------------------------------------------

# Preprocessing.
def preprocessing =
	( (--> preprocessingDirective) preprocessingDirective )*
end

def preprocessingDirective =
	( copyStatement
	| replaceStatement
	)
end


## #############################################################################
## COPY statement.
## -----------------------------------------------------------------------------

def copyStatement =  copyStatementBody .  end

private def copyStatementBody =
    COPY textName [ (OF | IN) libraryName ]
    [SUPPRESS [PRINTING]]
    [replacing]

  where def replacing =  REPLACING (replacementInstruction)+  end
end

def replacementInstruction =
	[leading | trailing] replacementOperand
	BY replacementOperand

  where def leading  =  LEADING   end
  where def trailing =  TRAILING  end
end

def replacementOperand = 
	( pseudoLiteral
	| literal
	| cobolWord
	)
end


## #############################################################################
## REPLACE statement.
## -----------------------------------------------------------------------------

def replaceStatement =
    REPLACE (replacing | off) .

  where def replacing =  [also: ALSO] (replacementInstruction)+  end
  where def off       =  [last: LAST] OFF                        end
end


## #############################################################################
## Lower level stuff.
## -----------------------------------------------------------------------------

def textName =
    ( cobolWord
    | alphanumericLiteral
    )
end

def libraryName =
    ( cobolWord
    | alphanumericLiteral
    )
end

def literal =
    ( numeric
    | alphanumericLiteral
    )
end

def numeric =
    ( integerLiteral
    | decimal
    | hexadecimal
    )
end

# -----------------------------------------------------------------------------
# Decimals
#
# Whether we're working on a decimal is something which can only be decided at
# parsing time. But it does require some lexer info.
#
# TODO Allow ",2"; which is still tricky.
def decimal =
    ( ('+' | '-') %noskip unsigned_decimal
    | unsigned_decimal
    )
end

private def unsigned_decimal =
    ( intgr %noskip ( (',' | '.') uintgr )
    | '.' %noskip uintgr
    )
end

private def intgr =
    @INTEGER_LITERAL _
end

private def uintgr =
    @UNSIGNED @INTEGER_LITERAL _
end
